<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta name="Content-Type" content="text/html; charset=UTF-8" />
<title>Class: GMP::Z</title>
<link rel="stylesheet" href="../css/style.css" type="text/css" media="screen" charset="utf-8" />
<link rel="stylesheet" href="../css/common.css" type="text/css" media="screen" charset="utf-8" />

<script type="text/javascript" charset="utf-8">
  relpath = '..';
  if (relpath != '') relpath += '/';
</script>
<script type="text/javascript" charset="utf-8" src="../js/jquery.js"></script>
<script type="text/javascript" charset="utf-8" src="../js/app.js"></script>

  </head>
  <body>
    <div id="header">
      <div id="menu">
  
    <a href="../_index.html">Index (Z)</a> &raquo; 
    <a href="../GMP.html" title="GMP">GMP</a>
     &raquo; 
    <span class="title">Z</span>
  
</div>

      <div id="search">
  <a id="class_list_link" href="#">Namespace List</a>
  <a id="method_list_link" href="#">Method List</a>
  <a id ="file_list_link" href="#">File List</a>
</div>

      <div class="clear"></div>
    </div>
    
    <iframe id="search_frame"></iframe>
    
    <div id="content"><h1>Class: GMP::Z 
  
  
</h1>

<dl class="box">
  
    <dt class="r1">Inherits:</dt>
    <dd class="r1">
      <span class="inheritName">Integer</span>
      
        <ul class="fullTree">
          <li>Object</li>
          
            <li class="next">Integer</li>
          
            <li class="next">GMP::Z</li>
          
        </ul>
        <a href="#" class="inheritanceTree">show all</a>
      
      </dd>
    
  
  
    
  
    
  
  
    <dt class="r2 last">Defined in:</dt>
    <dd class="r2 last">ext/gmp.c<span class="defines">,<br />
  ext/gmpz.c</span>
</dd>
  
</dl>
<div class="clear"></div>

<h2>Overview</h2><div class="docstring">
  <div class="discussion">
    <p>
GMP Multiple Precision Integer.
</p>
<p>
Instances of this class can store variables of the type mpz_t. This class
also contains many methods that act as the functions for mpz_t variables,
as well as a few methods that attempt to make this library more Ruby-ish.
</p>
<p>
The following list is just a simple checklist for me, really. A better
reference should be found in the rdocs.
</p>
<pre class="code">
  <span class='Ruby constant id'>Ruby</span> <span class='method identifier id'>method</span>    <span class='C constant id'>C</span> <span class='Extension constant id'>Extension</span> <span class='function identifier id'>function</span>    <span class='GMP constant id'>GMP</span> <span class='function identifier id'>function</span>
  <span class='to_d identifier id'>to_d</span>           <span class='r_gmpz_to_d identifier id'>r_gmpz_to_d</span>             <span class='mpz_get_d identifier id'>mpz_get_d</span>
  <span class='to_i identifier id'>to_i</span>           <span class='r_gmpz_to_i identifier id'>r_gmpz_to_i</span>             <span class='mpz_get_i identifier id'>mpz_get_i</span>
  <span class='to_s identifier id'>to_s</span>           <span class='r_gmpz_to_s identifier id'>r_gmpz_to_s</span>             <span class='mpz_get_s identifier id'>mpz_get_s</span>
  <span class='plus op'>+</span>              <span class='r_gmpz_add identifier id'>r_gmpz_add</span>              <span class='mpz_add identifier id'>mpz_add</span>
  <span class='add! fid id'>add!</span>           <span class='r_gmpz_add_self identifier id'>r_gmpz_add_self</span>         <span class='mpz_add identifier id'>mpz_add</span>
  <span class='minus op'>-</span>              <span class='r_gmpz_sub identifier id'>r_gmpz_sub</span>              <span class='mpz_sub identifier id'>mpz_sub</span>
  <span class='sub! fid id'>sub!</span>           <span class='r_gmpz_sub_self identifier id'>r_gmpz_sub_self</span>         <span class='mpz_sub identifier id'>mpz_sub</span>
  <span class='mult op'>*</span>              <span class='r_gmpz_mul identifier id'>r_gmpz_mul</span>              <span class='mpz_mul identifier id'>mpz_mul</span>
  <span class='regexp val'>/              r_gmpz_div              ...
  tdiv           r_gmpz_tdiv             mpz_tdiv_q
  tmod           r_gmpz_tmod             mpz_tdiv_r
  fdiv           r_gmpz_fdiv             mpz_fdiv_q
  fmod           r_gmpz_fmod             mpz_fdiv_r
  cdiv           r_gmpz_cdiv             mpz_cdiv_q
  cmod           r_gmpz_cmod             mpz_cdiv_r
  -@             r_gmpz_neg              mpz_neg
  neg            r_gmpz_neg              mpz_neg
  neg!           r_gmpz_neg_self         mpz_neg
  abs            r_gmpz_abs              mpz_abs
  abs!           r_gmpz_abs_self         mpz_abs
  **             r_gmpz_pow              mpz_pow_ui
  powmod         r_gmpz_powm             mpz_powm
  root           r_gmpz_root             mpz_root
  sqrt           r_gmpz_sqrt             mpz_sqrt
  sqrt!          r_gmpz_sqrt_self        mpz_sqrt
  sqrtrem        r_gmpz_sqrtrem          mpz_sqrtrem
  power?         r_gmpz_is_power         mpz_perfect_power_p
  square?        r_gmpz_is_square        mpz_perfect_square_p
  probab_prime?  r_gmpz_is_probab_prime  mpz_probab_prime_p
  nextprime      r_gmpz_nextprime        mpz_nextprime
  nextprime!     r_gmpz_nextprime_self   mpz_nextprime
  jacobi         r_gmpz_jacobi           mpz_jacobi
  #jacobi        r_gmpzsg_jacobi         mpz_jacobi
  legendre       r_gmpz_legendre         mpz_legendre
  remove         r_gmpz_remove           mpz_remove
  fac            r_gmpz_fac              mpz_fac_ui
  fib            r_gmpz_fib              mpz_fib_ui
  com            r_gmpz_com              mpz_com
  com!           r_gmpz_com_self         mpz_com
  []=            r_gmpz_setbit           mpz_setbit
  []             r_gmpz_getbit           mpz_tstbit
  scan0          r_gmpz_scan0            mpz_scan0
  scan1          r_gmpz_scan1            mpz_scan1
  even?          r_gmpz_is_even          mpz_even
  odd?           r_gmpz_is_odd           mpz_odd
  ...
</span></pre>


  </div>
</div>
<div class="tags">
  
</div>

  

  <h2>Class Method Summary</h2>

  <ul class="summary">
    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#fac-class_method" title="fac (class method)">+ (Object) <strong>fac</strong> </a>
    

    
  </span>
  
  
  
  
  

  
    <span class="summary_desc"></span>
  
</li>

    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#fib-class_method" title="fib (class method)">+ (Object) <strong>fib</strong> </a>
    

    
  </span>
  
  
  
  
  

  
    <span class="summary_desc"></span>
  
</li>

    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#jacobi-class_method" title="jacobi (class method)">+ (Object) <strong>jacobi</strong> </a>
    

    
  </span>
  
  
  
  
  

  
    <span class="summary_desc">
call-seq:.

</span>
  
</li>

    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#GMP%3A%3AZ.new-class_method" title="GMP::Z.new (class method)">+ (Object) <strong>GMP::Z.new</strong>(arg) </a>
    

    
  </span>
  
  
  
  
  

  
    <span class="summary_desc">
Creates a new GMP::Z integer, with arg as its value, converting where
necessary.

</span>
  
</li>

    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#pow-class_method" title="pow (class method)">+ (Object) <strong>pow</strong> </a>
    

    
  </span>
  
  
  
  
  

  
    <span class="summary_desc"></span>
  
</li>

    
  </ul>

  <h2>Instance Method Summary</h2>

  <ul class="summary">
    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#%26-instance_method" title="#&amp; (instance method)">- (Object) <strong>&amp;</strong> </a>
    

    
  </span>
  
  
  
  
  

  
    <span class="summary_desc"></span>
  
</li>

    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#%2A-instance_method" title="#* (instance method)">- (Object) <strong>*</strong>(other) </a>
    

    
  </span>
  
  
  
  
  

  
    <span class="summary_desc">
Multiplies this GMP::Z with other.

</span>
  
</li>

    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#%2A%2A-instance_method" title="#** (instance method)">- (Object) <strong>**</strong> </a>
    

    
  </span>
  
  
  
  
  

  
    <span class="summary_desc"></span>
  
</li>

    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#%2B-instance_method" title="#+ (instance method)">- (Object) <strong>+</strong>(other) </a>
    

    
  </span>
  
  
  
  
  

  
    <span class="summary_desc">
Adds this GMP::Z to other.

</span>
  
</li>

    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#--instance_method" title="#- (instance method)">- (Object) <strong>-</strong>(other) </a>
    

    
  </span>
  
  
  
  
  

  
    <span class="summary_desc">
Subtracts other from this GMP::Z.

</span>
  
</li>

    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#-%40-instance_method" title="#-@ (instance method)">- (Object) <strong>-@</strong> </a>
    

    
  </span>
  
  
  
  
  

  
    <span class="summary_desc"></span>
  
</li>

    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#%2F-instance_method" title="#/ (instance method)">- (Object) <strong>/</strong>(other) </a>
    

    
  </span>
  
  
  
  
  

  
    <span class="summary_desc">
Divides this GMP::Z by other.

</span>
  
</li>

    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#%3C-instance_method" title="#&lt; (instance method)">- (Object) <strong>&lt;</strong> </a>
    

    
  </span>
  
  
  
  
  

  
    <span class="summary_desc"></span>
  
</li>

    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#%3C%3C-instance_method" title="#&lt;&lt; (instance method)">- (Object) <strong>&lt;&lt;</strong> </a>
    

    
  </span>
  
  
  
  
  

  
    <span class="summary_desc"></span>
  
</li>

    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#%3C%3D-instance_method" title="#&lt;= (instance method)">- (Object) <strong>&lt;=</strong> </a>
    

    
  </span>
  
  
  
  
  

  
    <span class="summary_desc"></span>
  
</li>

    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#%3C%3D%3E-instance_method" title="#&lt;=&gt; (instance method)">- (Object) <strong>&lt;=&gt;</strong> </a>
    

    
  </span>
  
  
  
  
  

  
    <span class="summary_desc"></span>
  
</li>

    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#%3D%3D-instance_method" title="#== (instance method)">- (Object) <strong>==</strong> </a>
    

    
  </span>
  
  
  
  
  

  
    <span class="summary_desc">
*********************************************************************.

</span>
  
</li>

    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#%3E-instance_method" title="#&gt; (instance method)">- (Object) <strong>&gt;</strong> </a>
    

    
  </span>
  
  
  
  
  

  
    <span class="summary_desc"></span>
  
</li>

    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#%3E%3D-instance_method" title="#&gt;= (instance method)">- (Object) <strong>&gt;=</strong> </a>
    

    
  </span>
  
  
  
  
  

  
    <span class="summary_desc"></span>
  
</li>

    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#%3E%3E-instance_method" title="#&gt;&gt; (instance method)">- (Object) <strong>&gt;&gt;</strong> </a>
    

    
  </span>
  
  
  
  
  

  
    <span class="summary_desc"></span>
  
</li>

    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#%5B%5D-instance_method" title="#[] (instance method)">- (Object) <strong>[]</strong>(index) </a>
    

    
  </span>
  
  
  
  
  

  
    <span class="summary_desc">
Gets the bit at index, returned as either true or false.

</span>
  
</li>

    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#%5B%5D%3D-instance_method" title="#[]= (instance method)">- (Object) <strong>[]=</strong>(index) </a>
    

    
  </span>
  
  
  
  
  

  
    <span class="summary_desc">
Sets the bit at index to x.

</span>
  
</li>

    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#%5E-instance_method" title="#^ (instance method)">- (Object) <strong>^</strong> </a>
    

    
  </span>
  
  
  
  
  

  
    <span class="summary_desc"></span>
  
</li>

    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#abs-instance_method" title="#abs (instance method)">- (Object) <strong>abs</strong> </a>
    

    
  </span>
  
  
  
  
  

  
    <span class="summary_desc"></span>
  
</li>

    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#abs%21-instance_method" title="#abs! (instance method)">- (Object) <strong>abs!</strong> </a>
    

    
  </span>
  
  
  
  
  

  
    <span class="summary_desc"></span>
  
</li>

    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#add%21-instance_method" title="#add! (instance method)">- (Object) <strong>add!</strong>(other) </a>
    

    
  </span>
  
  
  
  
  

  
    <span class="summary_desc">
Adds this GMP::Z to other, and sets this GMP::Z&#8217;s value to the
result.

</span>
  
</li>

    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#cdiv-instance_method" title="#cdiv (instance method)">- (Object) <strong>cdiv</strong> </a>
    

    
  </span>
  
  
  
  
  

  
    <span class="summary_desc"></span>
  
</li>

    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#cmod-instance_method" title="#cmod (instance method)">- (Object) <strong>cmod</strong> </a>
    

    
  </span>
  
  
  
  
  

  
    <span class="summary_desc"></span>
  
</li>

    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#cmpabs-instance_method" title="#cmpabs (instance method)">- (Object) <strong>cmpabs</strong> </a>
    

    
  </span>
  
  
  
  
  

  
    <span class="summary_desc"></span>
  
</li>

    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#coerce-instance_method" title="#coerce (instance method)">- (Object) <strong>coerce</strong> </a>
    

    
  </span>
  
  
  
  
  

  
    <span class="summary_desc"></span>
  
</li>

    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#com-instance_method" title="#com (instance method)">- (Object) <strong>com</strong> </a>
    

    
  </span>
  
  
  
  
  

  
    <span class="summary_desc"></span>
  
</li>

    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#com%21-instance_method" title="#com! (instance method)">- (Object) <strong>com!</strong> </a>
    

    
  </span>
  
  
  
  
  

  
    <span class="summary_desc"></span>
  
</li>

    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#even%3F-instance_method" title="#even? (instance method)">- (Boolean) <strong>even?</strong> </a>
    

    
  </span>
  
  
  
  
  

  
    <span class="summary_desc"></span>
  
</li>

    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#fdiv-instance_method" title="#fdiv (instance method)">- (Object) <strong>fdiv</strong> </a>
    

    
  </span>
  
  
  
  
  

  
    <span class="summary_desc"></span>
  
</li>

    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#fmod-instance_method" title="#fmod (instance method)">- (Object) <strong>fmod</strong> </a>
    

    
  </span>
  
  
  
  
  

  
    <span class="summary_desc"></span>
  
</li>

    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#gcd-instance_method" title="#gcd (instance method)">- (Object) <strong>gcd</strong> </a>
    

    
  </span>
  
  
  
  
  

  
    <span class="summary_desc"></span>
  
</li>

    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#initialize-instance_method" title="#initialize (instance method)">- (Object) <strong>initialize</strong> </a>
    

    
  </span>
  
    <span class="note title constructor">constructor</span>
  
  
  
  
  

  
    <span class="summary_desc"></span>
  
</li>

    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#jacobi-instance_method" title="#jacobi (instance method)">- (Object) <strong>jacobi</strong> </a>
    

    
  </span>
  
  
  
  
  

  
    <span class="summary_desc">
call-seq:.

</span>
  
</li>

    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#lastbits_pos-instance_method" title="#lastbits_pos (instance method)">- (Object) <strong>lastbits_pos</strong> </a>
    

    
  </span>
  
  
  
  
  

  
    <span class="summary_desc"></span>
  
</li>

    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#lastbits_sgn-instance_method" title="#lastbits_sgn (instance method)">- (Object) <strong>lastbits_sgn</strong> </a>
    

    
  </span>
  
  
  
  
  

  
    <span class="summary_desc"></span>
  
</li>

    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#lcm-instance_method" title="#lcm (instance method)">- (Object) <strong>lcm</strong> </a>
    

    
  </span>
  
  
  
  
  

  
    <span class="summary_desc"></span>
  
</li>

    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#legendre-instance_method" title="#legendre (instance method)">- (Object) <strong>legendre</strong> </a>
    

    
  </span>
  
  
  
  
  

  
    <span class="summary_desc">
call-seq:.

</span>
  
</li>

    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#neg-instance_method" title="#neg (instance method)">- (Object) <strong>neg</strong> </a>
    

    
  </span>
  
  
  
  
  

  
    <span class="summary_desc"></span>
  
</li>

    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#neg%21-instance_method" title="#neg! (instance method)">- (Object) <strong>neg!</strong> </a>
    

    
  </span>
  
  
  
  
  

  
    <span class="summary_desc"></span>
  
</li>

    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#nextprime-instance_method" title="#nextprime (instance method)">- (Object) <strong>nextprime</strong> </a>
    

    
  </span>
  
  
  
  
  

  
    <span class="summary_desc"></span>
  
</li>

    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#nextprime%21-instance_method" title="#nextprime! (instance method)">- (Object) <strong>nextprime!</strong> </a>
    

    
  </span>
  
  
  
  
  

  
    <span class="summary_desc"></span>
  
</li>

    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#odd%3F-instance_method" title="#odd? (instance method)">- (Boolean) <strong>odd?</strong> </a>
    

    
  </span>
  
  
  
  
  

  
    <span class="summary_desc"></span>
  
</li>

    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#popcount-instance_method" title="#popcount (instance method)">- (Object) <strong>popcount</strong> </a>
    

    
  </span>
  
  
  
  
  

  
    <span class="summary_desc">
call-seq:.

</span>
  
</li>

    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#power%3F-instance_method" title="#power? (instance method)">- (Boolean) <strong>power?</strong> </a>
    

    
  </span>
  
  
  
  
  

  
    <span class="summary_desc"></span>
  
</li>

    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#powmod-instance_method" title="#powmod (instance method)">- (Object) <strong>powmod</strong>(exp, mod) </a>
    

    
  </span>
  
  
  
  
  

  
    <span class="summary_desc">
From the GMP Manual:.

</span>
  
</li>

    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#probab_prime%3F-instance_method" title="#probab_prime? (instance method)">- (Object) <strong>probab_prime?</strong>(reps = 5) </a>
    

    
  </span>
  
  
  
  
  

  
    <span class="summary_desc">
Determine whether <tt>n</tt> is prime.

</span>
  
</li>

    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#remove-instance_method" title="#remove (instance method)">- (Object) <strong>remove</strong> </a>
    

    
  </span>
  
  
  
  
  

  
    <span class="summary_desc">
call-seq:.

</span>
  
</li>

    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#root-instance_method" title="#root (instance method)">- (Object) <strong>root</strong> </a>
    

    
  </span>
  
  
  
  
  

  
    <span class="summary_desc"></span>
  
</li>

    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#scan0-instance_method" title="#scan0 (instance method)">- (Object) <strong>scan0</strong>(starting_bit) </a>
    

    
  </span>
  
  
  
  
  

  
    <span class="summary_desc">
From the GMP Manual:.

</span>
  
</li>

    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#scan1-instance_method" title="#scan1 (instance method)">- (Object) <strong>scan1</strong>(starting_bit) </a>
    

    
  </span>
  
  
  
  
  

  
    <span class="summary_desc">
From the GMP Manual:.

</span>
  
</li>

    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#sgn-instance_method" title="#sgn (instance method)">- (Object) <strong>sgn</strong> </a>
    

    
  </span>
  
  
  
  
  

  
    <span class="summary_desc">
From the GMP Manual:.

</span>
  
</li>

    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#sqrt-instance_method" title="#sqrt (instance method)">- (Object) <strong>sqrt</strong> </a>
    

    
  </span>
  
  
  
  
  

  
    <span class="summary_desc"></span>
  
</li>

    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#sqrt%21-instance_method" title="#sqrt! (instance method)">- (Object) <strong>sqrt!</strong> </a>
    

    
  </span>
  
  
  
  
  

  
    <span class="summary_desc"></span>
  
</li>

    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#sqrtrem-instance_method" title="#sqrtrem (instance method)">- (Object) <strong>sqrtrem</strong> </a>
    

    
  </span>
  
  
  
  
  

  
    <span class="summary_desc">
call-seq:.

</span>
  
</li>

    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#square%3F-instance_method" title="#square? (instance method)">- (Boolean) <strong>square?</strong> </a>
    

    
  </span>
  
  
  
  
  

  
    <span class="summary_desc"></span>
  
</li>

    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#sub%21-instance_method" title="#sub! (instance method)">- (Object) <strong>sub!</strong>(other) </a>
    

    
  </span>
  
  
  
  
  

  
    <span class="summary_desc">
Subtracts other from this GMP::Z, and sets this GMP::Z&#8217;s value to the
result.

</span>
  
</li>

    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#int2-instance_method" title="#int2 (instance method)">- (Object) <strong>int2</strong> </a>
    

    
  </span>
  
  
  
  
  

  
    <span class="summary_desc">
Efficiently swaps the contents of <tt>int1</tt> with <tt>int2</tt>.

</span>
  
</li>

    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#tdiv-instance_method" title="#tdiv (instance method)">- (Object) <strong>tdiv</strong> </a>
    

    
  </span>
  
  
  
  
  

  
    <span class="summary_desc"></span>
  
</li>

    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#tmod-instance_method" title="#tmod (instance method)">- (Object) <strong>tmod</strong> </a>
    

    
  </span>
  
  
  
  
  

  
    <span class="summary_desc"></span>
  
</li>

    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#to_d-instance_method" title="#to_d (instance method)">- (Object) <strong>to_d</strong> </a>
    

    
  </span>
  
  
  
  
  

  
    <span class="summary_desc">
Returns <tt>integer</tt> as an Float if <tt>integer</tt> fits in a Float.

</span>
  
</li>

    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#to_i-instance_method" title="#to_i (instance method)">- (Object) <strong>to_i</strong> </a>
    

    
  </span>
  
  
  
  
  

  
    <span class="summary_desc">
Returns <tt>integer</tt> as an Fixnum if <tt>integer</tt> fits in a Fixnum.

</span>
  
</li>

    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#to_s-instance_method" title="#to_s (instance method)">- (Object) <strong>to_s</strong> </a>
    

    
  </span>
  
  
  
  
  

  
    <span class="summary_desc">
call-seq:.

</span>
  
</li>

    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#tshr-instance_method" title="#tshr (instance method)">- (Object) <strong>tshr</strong> </a>
    

    
  </span>
  
  
  
  
  

  
    <span class="summary_desc"></span>
  
</li>

    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#%7C-instance_method" title="#| (instance method)">- (Object) <strong>|</strong> </a>
    

    
  </span>
  
  
  
  
  

  
    <span class="summary_desc"></span>
  
</li>

    
  </ul>

  <div id="constructor_details" class="method_details_list">
  <h2>Constructor Details</h2>
  
    <div class="method_details first">
  <p class="signature first" id="initialize-instance_method">
  
    - (<tt>Object</tt>) <strong>initialize</strong> 
  

  
</p>
</div>
  
</div>


  <div id="class_method_details" class="method_details_list">
    <h2>Class Method Details</h2>
    
    
      <div class="method_details first">
  <p class="signature first" id="fac-class_method">
  
    + (<tt>Object</tt>) <strong>fac</strong> 
  

  
</p>
</div>
    
      <div class="method_details ">
  <p class="signature " id="fib-class_method">
  
    + (<tt>Object</tt>) <strong>fib</strong> 
  

  
</p>
</div>
    
      <div class="method_details ">
  <p class="signature " id="jacobi-class_method">
  
    + (<tt>Object</tt>) <strong>jacobi</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
call-seq:
</p>
<pre class="code">
  <span class='GMP constant id'>GMP</span><span class='colon2 op'>::</span><span class='Z constant id'>Z</span><span class='dot token'>.</span><span class='jacobi identifier id'>jacobi</span><span class='lparen token'>(</span><span class='a identifier id'>a</span><span class='comma token'>,</span> <span class='b identifier id'>b</span><span class='rparen token'>)</span>
</pre>
<p>
From the GMP Manual:
</p>
<p>
Calculate the Jacobi symbol <tt>(a/b)</tt>. This is defined only for
<tt>b</tt> odd and positive.
</p>


  </div>
</div>
<div class="tags">
  
</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/gmpz.c'</span>

/*
 * Document-method: GMP::Z.jacobi
 *
 * call-seq:
 *   GMP::Z.jacobi(a, b)
 *
 * From the GMP Manual:
 * 
 * Calculate the Jacobi symbol &lt;tt&gt;(a/b)&lt;/tt&gt;. This is defined only for +b+
 * odd and positive.
 */
VALUE r_gmpzsg_jacobi(VALUE klass, VALUE a, VALUE b)
{
  MP_INT *a_val, *b_val;
  int res_val;
  int free_a_val = 0;
  int free_b_val = 0;
  (void)klass;
  
  if (GMPZ_P(a)) {
    mpz_get_struct(a, a_val);
  } else if (FIXNUM_P(a)) {
    mpz_temp_alloc(a_val);
    mpz_init_set_ui(a_val, FIX2INT(a));
    free_a_val = 1;
  } else if (BIGNUM_P(a)) {
    mpz_temp_from_bignum(a_val, a);
    free_a_val = 1;
  } else {
    typeerror_as(ZXB, &quot;a&quot;);
  }
  
  if (GMPZ_P(b)) {
    mpz_get_struct(b, b_val);
    if (mpz_sgn(b_val) != 1)
      rb_raise(rb_eRangeError, &quot;Cannot take Jacobi symbol (a/b) where b is non-positive.&quot;);
    if (mpz_even_p(b_val))
      rb_raise(rb_eRangeError, &quot;Cannot take Jacobi symbol (a/b) where b is even.&quot;);
  } else if (FIXNUM_P(b)) {
    if (FIX2INT(b) &lt;= 0)
      rb_raise(rb_eRangeError, &quot;Cannot take Jacobi symbol (a/b) where b is non-positive.&quot;);
    if (FIX2INT(b) % 2 == 0)
      rb_raise(rb_eRangeError, &quot;Cannot take Jacobi symbol (a/b) where b is even.&quot;);
    mpz_temp_alloc(b_val);
    mpz_init_set_ui(b_val, FIX2INT(b));
    free_b_val = 1;
  } else if (BIGNUM_P(b)) {
    mpz_temp_from_bignum(b_val, b);
    if (mpz_sgn(b_val) != 1) {
      mpz_temp_free(b_val);
      rb_raise(rb_eRangeError, &quot;Cannot take Jacobi symbol (a/b) where b is non-positive.&quot;);
    }
    if (mpz_even_p(b_val)) {
      mpz_temp_free(b_val);
      rb_raise(rb_eRangeError, &quot;Cannot take Jacobi symbol (a/b) where b is even.&quot;);
    }
    free_b_val = 1;
  } else {
    typeerror_as(ZXB, &quot;b&quot;);
  }
  
  res_val = mpz_jacobi(a_val, b_val);
  if (free_a_val) { mpz_temp_free(a_val); }
  if (free_b_val) { mpz_temp_free(b_val); }
  return INT2FIX(res_val);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="new-class_method">
  
    + (<tt>Object</tt>) <strong>GMP::Z.new</strong>(arg) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Creates a new GMP::Z integer, with arg as its value, converting where
necessary.
</p>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/gmpz.c'</span>

/*
 * call-seq:
 *   GMP::Z.new(arg)
 *
 * Creates a new GMP::Z integer, with arg as its value, converting where
 * necessary.
 */
VALUE r_gmpzsg_new(int argc, VALUE *argv, VALUE klass)
{
  MP_INT *res_val;
  VALUE res;

  (void)klass;

  if (argc &gt; 1)
    rb_raise(rb_eArgError, &quot;wrong # of arguments (%d for 0 or 1)&quot;, argc);

  mpz_make_struct(res, res_val);
  mpz_init(res_val);

  rb_obj_call_init(res, argc, argv);

  return res;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="pow-class_method">
  
    + (<tt>Object</tt>) <strong>pow</strong> 
  

  
</p>
</div>
    
  </div>

  <div id="instance_method_details" class="method_details_list">
    <h2>Instance Method Details</h2>
    
    
      <div class="method_details first">
  <p class="signature first" id="&-instance_method">
  
    - (<tt>Object</tt>) <strong>&amp;</strong> 
  

  
</p>
</div>
    
      <div class="method_details ">
  <p class="signature " id="*-instance_method">
  
    - (<tt>Object</tt>) <strong>*</strong>(other) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Multiplies this GMP::Z with other. Other can be
</p>
<ul>
<li>GMP::Z

</li>
<li>Fixnum

</li>
<li>GMP::Q

</li>
<li>GMP::F

</li>
<li>Bignum

</li>
</ul>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/gmpz.c'</span>

/*
 * call-seq:
 *   *(other)
 *
 * Multiplies this GMP::Z with other. Other can be
 * * GMP::Z
 * * Fixnum
 * * GMP::Q
 * * GMP::F
 * * Bignum
 */
VALUE r_gmpz_mul(VALUE self, VALUE arg)
{
  MP_INT *self_val, *arg_val, *res_val;
  VALUE res;

  mpz_get_struct(self,self_val);

  if (GMPZ_P(arg)) {
    mpz_make_struct_init(res, res_val);
    mpz_get_struct(arg,arg_val);
    mpz_mul(res_val, self_val, arg_val);
  } else if (FIXNUM_P(arg)) {
    mpz_make_struct_init(res, res_val);
    mpz_mul_si(res_val, self_val, FIX2INT(arg));
  } else if (GMPQ_P(arg)) {
    return r_gmpq_mul(arg, self);
  } else if (GMPF_P(arg)) {
    return r_gmpf_mul(arg, self);
  } else if (BIGNUM_P(arg)) {
    mpz_make_struct_init(res, res_val);
    mpz_set_bignum(res_val, arg);
    mpz_mul(res_val, res_val, self_val);
  } else {
    typeerror(ZQFXB);
  }
  return res;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="**-instance_method">
  
    - (<tt>Object</tt>) <strong>**</strong> 
  

  
</p>
</div>
    
      <div class="method_details ">
  <p class="signature " id="+-instance_method">
  
    - (<tt>Object</tt>) <strong>+</strong>(other) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Adds this GMP::Z to other. Other can be
</p>
<ul>
<li>GMP::Z

</li>
<li>Fixnum

</li>
<li>GMP::Q

</li>
<li>GMP::F

</li>
<li>Bignum

</li>
</ul>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/gmpz.c'</span>

/*
 * call-seq:
 *   +(other)
 *
 * Adds this GMP::Z to other. Other can be
 * * GMP::Z
 * * Fixnum
 * * GMP::Q
 * * GMP::F
 * * Bignum
 */
VALUE r_gmpz_add(VALUE self, VALUE arg)
{
  MP_INT *self_val, *arg_val, *res_val;
  VALUE res;

  mpz_get_struct(self,self_val);

  if (GMPZ_P(arg)) {
    mpz_get_struct(arg,arg_val);
    mpz_make_struct_init(res, res_val);
    mpz_add(res_val, self_val, arg_val);
  } else if (FIXNUM_P(arg)) {
    mpz_make_struct_init(res, res_val);
    if (FIX2INT(arg) &gt; 0)
      mpz_add_ui(res_val, self_val, FIX2INT(arg));
    else
      mpz_sub_ui(res_val, self_val, -FIX2INT(arg));
  } else if (GMPQ_P(arg)) {
    return r_gmpq_add(arg, self);
  } else if (GMPF_P(arg)) {
    return r_gmpf_add(arg, self);
  } else if (BIGNUM_P(arg)) {
    mpz_make_struct_init(res, res_val);
    mpz_init(res_val);
    mpz_set_bignum(res_val, arg);
    mpz_add(res_val, res_val, self_val);
  } else {
    typeerror(ZQFXB);
  }
  return res;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="--instance_method">
  
    - (<tt>Object</tt>) <strong>-</strong>(other) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Subtracts other from this GMP::Z. Other can be
</p>
<ul>
<li>GMP::Z

</li>
<li>Fixnum

</li>
<li>GMP::Q

</li>
<li>GMP::F

</li>
<li>Bignum

</li>
</ul>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/gmpz.c'</span>

/*
 * call-seq:
 *   -(other)
 *
 * Subtracts other from this GMP::Z. Other can be
 * * GMP::Z
 * * Fixnum
 * * GMP::Q
 * * GMP::F
 * * Bignum
 */
VALUE r_gmpz_sub(VALUE self, VALUE arg)
{
  MP_RAT *res_val_q, *arg_val_q;
  MP_INT *self_val, *arg_val, *res_val;
  MP_FLOAT *arg_val_f, *res_val_f;
  VALUE res;
  unsigned long prec;

  mpz_get_struct(self,self_val);

  if (GMPZ_P(arg)) {
    mpz_make_struct_init(res, res_val);
    mpz_get_struct(arg,arg_val);
    mpz_sub (res_val, self_val, arg_val);
  } else if (FIXNUM_P(arg)) {
    mpz_make_struct_init(res, res_val);
    if (FIX2INT(arg) &gt; 0)
      mpz_sub_ui (res_val, self_val, FIX2INT(arg));
    else
      mpz_add_ui (res_val, self_val, -FIX2INT(arg));
  } else if (GMPQ_P(arg)) {
    mpq_make_struct_init(res, res_val_q);
    mpq_get_struct(arg,arg_val_q);
    mpz_set (mpq_denref(res_val_q), mpq_denref(arg_val_q));
    mpz_mul (mpq_numref(res_val_q), mpq_denref(arg_val_q), self_val);
    mpz_sub (mpq_numref(res_val_q), mpq_numref(res_val_q), mpq_numref(arg_val_q));
  } else if (GMPF_P(arg)) {
    mpf_get_struct_prec (arg, arg_val_f, prec);
    mpf_make_struct_init(res, res_val_f, prec);
    mpf_set_z (res_val_f, self_val);
    mpf_sub (res_val_f, res_val_f, arg_val_f);
  } else if (BIGNUM_P(arg)) {
    mpz_make_struct_init(res, res_val);
    mpz_set_bignum (res_val, arg);
    mpz_sub (res_val, self_val, res_val);
  } else {
    typeerror (ZQFXB);
  }
  return res;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="-@-instance_method">
  
    - (<tt>Object</tt>) <strong>-@</strong> 
  

  
</p>
</div>
    
      <div class="method_details ">
  <p class="signature " id="/-instance_method">
  
    - (<tt>Object</tt>) <strong>/</strong>(other) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Divides this GMP::Z by other. Other can be
</p>
<ul>
<li>GMP::Z

</li>
<li>Fixnum

</li>
<li>GMP::Q

</li>
<li>GMP::F

</li>
<li>Bignum

</li>
</ul>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/gmpz.c'</span>

/*
 * call-seq:
 *   /(other)
 *
 * Divides this GMP::Z by other. Other can be
 * * GMP::Z
 * * Fixnum
 * * GMP::Q
 * * GMP::F
 * * Bignum
 */
VALUE r_gmpz_div(VALUE self, VALUE arg)
{
  MP_INT *self_val, *arg_val_z, *tmp_z;
  MP_RAT *arg_val_q, *res_val_q;
  MP_FLOAT *arg_val_f, *res_val_f;
  VALUE res;
  unsigned int prec;

  mpz_get_struct(self,self_val);

  if (GMPZ_P(arg)) {
    mpz_get_struct(arg, arg_val_z);
    if (mpz_cmp_ui(arg_val_z, 0) == 0)
      rb_raise(rb_eZeroDivError, &quot;divided by 0&quot;);
    mpq_make_struct_init(res, res_val_q);
    mpq_set_num(res_val_q, self_val);
    mpq_set_den(res_val_q, arg_val_z);
    mpq_canonicalize (res_val_q);
  } else if (FIXNUM_P(arg)) {
    if (FIX2INT(arg) == 0)
      rb_raise(rb_eZeroDivError, &quot;divided by 0&quot;);
    mpq_make_struct_init(res, res_val_q);
    mpq_set_num(res_val_q, self_val);
    mpz_set_ui(mpq_denref(res_val_q), FIX2INT(arg));
    mpq_canonicalize (res_val_q);
  } else if (GMPQ_P(arg)) {
    mpq_get_struct(arg, arg_val_q);
    if (mpz_cmp_ui(mpq_numref(arg_val_q), 0) == 0)
      rb_raise(rb_eZeroDivError, &quot;divided by 0&quot;);
    mpz_temp_init(tmp_z);
    mpq_make_struct_init(res, res_val_q);
    mpz_gcd(tmp_z, mpq_numref(arg_val_q), self_val);
    mpz_divexact(mpq_numref(res_val_q), self_val, tmp_z);
    mpz_divexact(mpq_denref(res_val_q), mpq_numref(arg_val_q), tmp_z);
    mpz_mul(mpq_numref(res_val_q), mpq_numref(res_val_q), mpq_denref(arg_val_q));
    mpz_temp_free(tmp_z);
  } else if (GMPF_P(arg)) {
    mpf_get_struct_prec(arg, arg_val_f, prec);
    mpf_make_struct_init(res, res_val_f, prec);
    mpf_set_z(res_val_f, self_val);
    mpf_div(res_val_f, res_val_f, arg_val_f);
  } else if (BIGNUM_P(arg)) {
    mpq_make_struct_init(res, res_val_q);
    mpz_set_bignum(mpq_denref(res_val_q), arg);
    if (mpz_cmp_ui(mpq_denref(res_val_q), 0) == 0)
      rb_raise(rb_eZeroDivError, &quot;divided by 0&quot;);
    mpq_set_num(res_val_q, self_val);
    mpq_canonicalize(res_val_q);
  } else {
    typeerror(ZQFXB);
  }
  return res;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="<-instance_method">
  
    - (<tt>Object</tt>) <strong>&lt;</strong> 
  

  
</p>
</div>
    
      <div class="method_details ">
  <p class="signature " id="<<-instance_method">
  
    - (<tt>Object</tt>) <strong>&lt;&lt;</strong> 
  

  
</p>
</div>
    
      <div class="method_details ">
  <p class="signature " id="<=-instance_method">
  
    - (<tt>Object</tt>) <strong>&lt;=</strong> 
  

  
</p>
</div>
    
      <div class="method_details ">
  <p class="signature " id="<=>-instance_method">
  
    - (<tt>Object</tt>) <strong>&lt;=&gt;</strong> 
  

  
</p>
</div>
    
      <div class="method_details ">
  <p class="signature " id="==-instance_method">
  
    - (<tt>Object</tt>) <strong>==</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
*********************************************************************
</p>
<pre class="code">
    <span class='Integer constant id'>Integer</span> <span class='Comparisons constant id'>Comparisons</span>                                             <span class='mult op'>*</span>
</pre>
<p>
********************************************************************
</p>


  </div>
</div>
<div class="tags">
  
</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/gmpz.c'</span>

/**********************************************************************
 *    Integer Comparisons                                             *
 **********************************************************************/

VALUE r_gmpz_eq(VALUE self, VALUE arg)
{
  MP_INT *self_val, *arg_val_z;
  MP_RAT *arg_val_q;

  mpz_get_struct (self, self_val);
  if (GMPZ_P(arg)) {
    mpz_get_struct(arg, arg_val_z);
    return (mpz_cmp (self_val, arg_val_z)==0) ? Qtrue : Qfalse;
  } else if (FIXNUM_P(arg)) {
    return (mpz_cmp_si (self_val, FIX2INT(arg))==0) ? Qtrue : Qfalse;
  } else if (GMPQ_P(arg)) {
    mpq_get_struct(arg, arg_val_q);
    if (mpz_cmp_ui(mpq_denref(arg_val_q), 1)==0)
      return Qfalse;
    return (mpz_cmp (self_val, mpq_numref(arg_val_q))==0) ? Qtrue : Qfalse;
  } else if (BIGNUM_P(arg)) {
    mpz_temp_from_bignum(arg_val_z, arg);
    if (mpz_cmp (self_val, arg_val_z)==0) {
      mpz_temp_free(arg_val_z);
      return Qtrue;
    } else {
      mpz_temp_free(arg_val_z);
      return Qfalse;
    }
  } else {
    return Qfalse;
  }
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id=">-instance_method">
  
    - (<tt>Object</tt>) <strong>&gt;</strong> 
  

  
</p>
</div>
    
      <div class="method_details ">
  <p class="signature " id=">=-instance_method">
  
    - (<tt>Object</tt>) <strong>&gt;=</strong> 
  

  
</p>
</div>
    
      <div class="method_details ">
  <p class="signature " id=">>-instance_method">
  
    - (<tt>Object</tt>) <strong>&gt;&gt;</strong> 
  

  
</p>
</div>
    
      <div class="method_details ">
  <p class="signature " id="[]-instance_method">
  
    - (<tt>Object</tt>) <strong>[]</strong>(index) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Gets the bit at index, returned as either true or false.
</p>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/gmpz.c'</span>

/*
 * call-seq:
 *   integer[index] &amp;rarr; boolean
 *
 * Gets the bit at index, returned as either true or false.
 */
VALUE r_gmpz_getbit(VALUE self, VALUE bitnr)
{
  MP_INT *self_val;
  int bitnr_val;
  mpz_get_struct(self, self_val);
  if (FIXNUM_P(bitnr)) {
    bitnr_val = FIX2INT (bitnr);
  } else {
    typeerror_as(X, &quot;index&quot;);
  }
  return mpz_tstbit(self_val, bitnr_val)?Qtrue:Qfalse;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="[]=-instance_method">
  
    - (<tt>Object</tt>) <strong>[]=</strong>(index) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Sets the bit at index to x.
</p>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/gmpz.c'</span>

/*
 * call-seq:
 *   integer[index] = x &amp;rarr; nil
 *
 * Sets the bit at index to x.
 */
VALUE r_gmpz_setbit(VALUE self, VALUE bitnr, VALUE set_to)
{
  MP_INT *self_val;
  int bitnr_val;

  mpz_get_struct(self, self_val);

  if (FIXNUM_P(bitnr)) {
    bitnr_val = FIX2INT (bitnr);
  } else {
    typeerror_as(X, &quot;index&quot;);
  }
  if (RTEST(set_to)) {
    mpz_setbit(self_val, bitnr_val);
  } else {
    mpz_clrbit(self_val, bitnr_val);
  }
  return Qnil;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="^-instance_method">
  
    - (<tt>Object</tt>) <strong>^</strong> 
  

  
</p>
</div>
    
      <div class="method_details ">
  <p class="signature " id="abs-instance_method">
  
    - (<tt>Object</tt>) <strong>abs</strong> 
  

  
</p>
</div>
    
      <div class="method_details ">
  <p class="signature " id="abs!-instance_method">
  
    - (<tt>Object</tt>) <strong>abs!</strong> 
  

  
</p>
</div>
    
      <div class="method_details ">
  <p class="signature " id="add!-instance_method">
  
    - (<tt>Object</tt>) <strong>add!</strong>(other) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Adds this GMP::Z to other, and sets this GMP::Z&#8217;s value to the
result. Other can be
</p>
<ul>
<li>GMP::Z

</li>
<li>Fixnum

</li>
<li>GMP::Q

</li>
<li>GMP::F

</li>
<li>Bignum

</li>
</ul>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/gmpz.c'</span>

/*
 * call-seq:
 *   add!(other)
 *
 * Adds this GMP::Z to other, and sets this GMP::Z's value to the result. Other
 * can be
 * * GMP::Z
 * * Fixnum
 * * GMP::Q
 * * GMP::F
 * * Bignum
 */
VALUE r_gmpz_add_self(VALUE self, VALUE arg)
{
  MP_INT *self_val, *arg_val;

  mpz_get_struct(self,self_val);

  if (GMPZ_P(arg)) {
    mpz_get_struct(arg,arg_val);
    mpz_add(self_val, self_val, arg_val);
  } else if (FIXNUM_P(arg)) {
    if (FIX2INT(arg) &gt; 0)
      mpz_add_ui(self_val, self_val, FIX2INT(arg));
    else
      mpz_sub_ui(self_val, self_val, -FIX2INT(arg));
  } else if (BIGNUM_P(arg)) {
    mpz_temp_from_bignum(arg_val, arg);
    mpz_add(self_val, self_val, arg_val);
    mpz_temp_free(arg_val);
  } else {
    typeerror(ZXB);
  }
  return Qnil;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="cdiv-instance_method">
  
    - (<tt>Object</tt>) <strong>cdiv</strong> 
  

  
</p>
</div>
    
      <div class="method_details ">
  <p class="signature " id="cmod-instance_method">
  
    - (<tt>Object</tt>) <strong>cmod</strong> 
  

  
</p>
</div>
    
      <div class="method_details ">
  <p class="signature " id="cmpabs-instance_method">
  
    - (<tt>Object</tt>) <strong>cmpabs</strong> 
  

  
</p>
</div>
    
      <div class="method_details ">
  <p class="signature " id="coerce-instance_method">
  
    - (<tt>Object</tt>) <strong>coerce</strong> 
  

  
</p>
</div>
    
      <div class="method_details ">
  <p class="signature " id="com-instance_method">
  
    - (<tt>Object</tt>) <strong>com</strong> 
  

  
</p>
</div>
    
      <div class="method_details ">
  <p class="signature " id="com!-instance_method">
  
    - (<tt>Object</tt>) <strong>com!</strong> 
  

  
</p>
</div>
    
      <div class="method_details ">
  <p class="signature " id="even?-instance_method">
  
    - (<tt>Boolean</tt>) <strong>even?</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
</div>
    
      <div class="method_details ">
  <p class="signature " id="fdiv-instance_method">
  
    - (<tt>Object</tt>) <strong>fdiv</strong> 
  

  
</p>
</div>
    
      <div class="method_details ">
  <p class="signature " id="fmod-instance_method">
  
    - (<tt>Object</tt>) <strong>fmod</strong> 
  

  
</p>
</div>
    
      <div class="method_details ">
  <p class="signature " id="gcd-instance_method">
  
    - (<tt>Object</tt>) <strong>gcd</strong> 
  

  
</p>
</div>
    
      <div class="method_details ">
  <p class="signature " id="jacobi-instance_method">
  
    - (<tt>Object</tt>) <strong>jacobi</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
call-seq:
</p>
<pre class="code">
  <span class='a identifier id'>a</span><span class='dot token'>.</span><span class='jacobi identifier id'>jacobi</span><span class='lparen token'>(</span><span class='b identifier id'>b</span><span class='rparen token'>)</span>
</pre>
<p>
From the GMP Manual:
</p>
<p>
Calculate the Jacobi symbol <tt>(a/b)</tt>. This is defined only for
<tt>b</tt> odd and positive.
</p>


  </div>
</div>
<div class="tags">
  
</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/gmpz.c'</span>

/*
 * Document-method: jacobi
 *
 * call-seq:
 *   a.jacobi(b)
 *
 * From the GMP Manual:
 * 
 * Calculate the Jacobi symbol &lt;tt&gt;(a/b)&lt;/tt&gt;. This is defined only for +b+
 * odd and positive.
 */
VALUE r_gmpz_jacobi(VALUE self, VALUE b)
{
  MP_INT *self_val, *b_val;
  int res_val;
  mpz_get_struct(self, self_val);
  mpz_get_struct(   b,    b_val);
  if (mpz_sgn(b_val) != 1)
    rb_raise(rb_eRangeError, &quot;Cannot take Jacobi symbol (a/b) where b is non-positive.&quot;);
  if (mpz_even_p(b_val))
    rb_raise(rb_eRangeError, &quot;Cannot take Jacobi symbol (a/b) where b is even.&quot;);
  res_val = mpz_jacobi(self_val, b_val);
  return INT2FIX(res_val);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="lastbits_pos-instance_method">
  
    - (<tt>Object</tt>) <strong>lastbits_pos</strong> 
  

  
</p>
</div>
    
      <div class="method_details ">
  <p class="signature " id="lastbits_sgn-instance_method">
  
    - (<tt>Object</tt>) <strong>lastbits_sgn</strong> 
  

  
</p>
</div>
    
      <div class="method_details ">
  <p class="signature " id="lcm-instance_method">
  
    - (<tt>Object</tt>) <strong>lcm</strong> 
  

  
</p>
</div>
    
      <div class="method_details ">
  <p class="signature " id="legendre-instance_method">
  
    - (<tt>Object</tt>) <strong>legendre</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
call-seq:
</p>
<pre class="code">
  <span class='a identifier id'>a</span><span class='dot token'>.</span><span class='legendre identifier id'>legendre</span><span class='lparen token'>(</span><span class='p identifier id'>p</span><span class='rparen token'>)</span>
</pre>
<p>
From the GMP Manual:
</p>
<p>
Calculate the Legendre symbol <tt>(a/p)</tt>. This is defined only for
<tt>p</tt> an odd positive prime, and for such <tt>p</tt> it&#8217;s
identical to the Jacobi symbol.
</p>


  </div>
</div>
<div class="tags">
  
</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/gmpz.c'</span>

/*
 * Document-method: legendre
 *
 * call-seq:
 *   a.legendre(p)
 *
 * From the GMP Manual:
 * 
 * Calculate the Legendre symbol &lt;tt&gt;(a/p)&lt;/tt&gt;. This is defined only for +p+
 * an odd positive prime, and for such +p+ it's identical to the Jacobi symbol. 
 */
VALUE r_gmpz_legendre(VALUE self, VALUE p)
{
  MP_INT *self_val, *p_val;
  int res_val;
  mpz_get_struct(self, self_val);
  mpz_get_struct(   p,    p_val);
  if (mpz_sgn(p_val) != 1)
    rb_raise(rb_eRangeError, &quot;Cannot take Legendre symbol (a/p) where p is non-positive.&quot;);
  if (mpz_even_p(p_val))
    rb_raise(rb_eRangeError, &quot;Cannot take Legendre symbol (a/p) where p is even.&quot;);
  if (mpz_probab_prime_p(p_val, 5) == 0)
    rb_raise(rb_eRangeError, &quot;Cannot take Legendre symbol (a/p) where p is composite.&quot;);
  res_val = mpz_legendre(self_val, p_val);
  return INT2FIX(res_val);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="neg-instance_method">
  
    - (<tt>Object</tt>) <strong>neg</strong> 
  

  
</p>
</div>
    
      <div class="method_details ">
  <p class="signature " id="neg!-instance_method">
  
    - (<tt>Object</tt>) <strong>neg!</strong> 
  

  
</p>
</div>
    
      <div class="method_details ">
  <p class="signature " id="nextprime-instance_method">
  
    - (<tt>Object</tt>) <strong>nextprime</strong> 
  

  
</p>
</div>
    
      <div class="method_details ">
  <p class="signature " id="nextprime!-instance_method">
  
    - (<tt>Object</tt>) <strong>nextprime!</strong> 
  

  
</p>
</div>
    
      <div class="method_details ">
  <p class="signature " id="odd?-instance_method">
  
    - (<tt>Boolean</tt>) <strong>odd?</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
</div>
    
      <div class="method_details ">
  <p class="signature " id="popcount-instance_method">
  
    - (<tt>Object</tt>) <strong>popcount</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
call-seq:
</p>
<pre class="code">
  <span class='integer identifier id'>integer</span><span class='dot token'>.</span><span class='popcount identifier id'>popcount</span>
</pre>
<p>
From the GMP Manual:
</p>
<p>
If <tt>integer&gt;=0</tt>, return the population count of <tt>integer</tt>,
which is the number of 1 bits in the binary representation. If
<tt>op&lt;0</tt>, the number of 1s is infinite, and the return value is
INT2FIX(ULONG_MAX), the largest possible unsigned long.
</p>


  </div>
</div>
<div class="tags">
  
</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/gmpz.c'</span>

/*
 * Document-method: popcount
 *
 * call-seq:
 *   integer.popcount
 *
 * From the GMP Manual:
 * 
 * If &lt;tt&gt;integer&gt;=0&lt;/tt&gt;, return the population count of &lt;tt&gt;integer&lt;/tt&gt;,
 * which is the number of 1 bits in the binary representation. If
 * &lt;tt&gt;op&lt;0&lt;/tt&gt;, the number of 1s is infinite, and the return value is
 * INT2FIX(ULONG_MAX), the largest possible unsigned long.
 */
VALUE r_gmpz_popcount(VALUE self)
{
  MP_INT *self_val;
  mpz_get_struct(self, self_val);
  return INT2FIX(mpz_popcount(self_val));
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="power?-instance_method">
  
    - (<tt>Boolean</tt>) <strong>power?</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
</div>
    
      <div class="method_details ">
  <p class="signature " id="powmod-instance_method">
  
    - (<tt>Object</tt>) <strong>powmod</strong>(exp, mod) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
From the GMP Manual:
</p>
<p>
Returns <tt>integer</tt> raised to <tt>exp</tt> modulo <tt>mod</tt>.
</p>
<p>
Negative <tt>exp</tt> is supported if an inverse <tt>integer^-1</tt> mod
<tt>mod</tt> exists. If an inverse doesn&#8217;t exist then a divide by
zero is raised.
</p>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/gmpz.c'</span>

/*
 * call-seq:
 *   integer.powmod(exp, mod)
 *
 * From the GMP Manual:
 * 
 * Returns +integer+ raised to +exp+ modulo +mod+.
 *
 * Negative +exp+ is supported if an inverse &lt;tt&gt;integer^-1&lt;/tt&gt; mod
 * &lt;tt&gt;mod&lt;/tt&gt; exists. If an inverse doesn't exist then a divide by zero is
 * raised.
 */
VALUE r_gmpz_powm(VALUE self, VALUE exp, VALUE mod)
{
  MP_INT *self_val, *res_val, *mod_val, *exp_val;
  VALUE res;
  int free_mod_val = 0;

  if (GMPZ_P(mod)) {
    mpz_get_struct(mod, mod_val);
    if (mpz_sgn(mod_val) &lt;= 0) {
      rb_raise(rb_eRangeError, &quot;modulus must be positive&quot;);
    }
  } else if (FIXNUM_P(mod)) {
    if (FIX2INT(mod) &lt;= 0) {
      rb_raise(rb_eRangeError, &quot;modulus must be positive&quot;);
    }
    mpz_temp_alloc(mod_val);
    mpz_init_set_ui(mod_val, FIX2INT(mod));
    free_mod_val = 1;
  } else if (BIGNUM_P(mod)) {
    mpz_temp_from_bignum(mod_val, mod);
    if (mpz_sgn(mod_val) &lt;= 0) {
      mpz_temp_free(mod_val);
      rb_raise(rb_eRangeError, &quot;modulus must be positive&quot;);
    }
    free_mod_val = 1;
  } else {
    typeerror_as(ZXB, &quot;modulus&quot;);
  }
  mpz_make_struct_init(res, res_val);
  mpz_get_struct(self, self_val);

  if (GMPZ_P(exp)) {
    mpz_get_struct(exp, exp_val);
    if (mpz_sgn(mod_val) &lt; 0) {
      rb_raise(rb_eRangeError, &quot;exponent must be nonnegative&quot;);
    }
    mpz_powm(res_val, self_val, exp_val, mod_val);
  } else if (FIXNUM_P(exp)) {
    if (FIX2INT(exp) &lt; 0)
    {
      if (free_mod_val)
        mpz_temp_free(mod_val);
      rb_raise(rb_eRangeError, &quot;exponent must be nonnegative&quot;);
    }
    mpz_powm_ui(res_val, self_val, FIX2INT(exp), mod_val);
  } else if (BIGNUM_P(exp)) {
    mpz_temp_from_bignum(exp_val, exp);
    mpz_powm(res_val, self_val, exp_val, mod_val);
    mpz_temp_free(exp_val);
  } else {
    if (free_mod_val)
      mpz_temp_free(mod_val);
    typeerror_as(ZXB, &quot;exponent&quot;);
  }
  if (free_mod_val)
    mpz_temp_free(mod_val);
  return res;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="probab_prime?-instance_method">
  
    - (<tt>Object</tt>) <strong>probab_prime?</strong>(reps = 5) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Determine whether <tt>n</tt> is prime. Returns 2 if <tt>n</tt> is
definitely prime, returns 1 if <tt>n</tt> is probably prime (without being
certain), or returns 0 if <tt>n</tt> is definitely composite.
</p>
<p>
This function does some trial divisions, then some Miller-Rabin
probabilistic primality tests. <tt>reps</tt> controls how many such tests
are done, 5 to 10 is a reasonable number, more will reduce the chances of a
composite being returned as &quot;probably prime&quot;.
</p>
<p>
Miller-Rabin and similar tests can be more properly called compositeness
tests. Numbers which fail are known to be composite but those which pass
might be prime or might be composite. Only a few composites pass, hence
those which pass are considered probably prime.
</p>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/gmpz.c'</span>

/*
 * call-seq: probab_prime?(reps = 5)
 *
 * Determine whether +n+ is prime. Returns 2 if +n+ is definitely prime,
 * returns 1 if +n+ is probably prime (without being certain), or returns 0 if
 * +n+ is definitely composite.
 *
 * This function does some trial divisions, then some Miller-Rabin
 * probabilistic primality tests. +reps+ controls how many such tests are done,
 * 5 to 10 is a reasonable number, more will reduce the chances of a composite
 * being returned as &quot;probably prime&quot;.
 *
 * Miller-Rabin and similar tests can be more properly called compositeness
 * tests. Numbers which fail are known to be composite but those which pass
 * might be prime or might be composite. Only a few composites pass, hence
 * those which pass are considered probably prime.
 */
VALUE r_gmpz_is_probab_prime(int argc, VALUE* argv, VALUE self)
{
  MP_INT *self_val;
  int reps_val;
  VALUE reps;
  mpz_get_struct(self, self_val);
  rb_scan_args(argc, argv, &quot;01&quot;, &amp;reps);
  if(NIL_P(reps)){
    reps = INT2FIX(5);
  }
  if (FIXNUM_P(reps)) {
    reps_val = FIX2INT (reps);
  } else {
    typeerror_as(X, &quot;reps&quot;);
  }
  return INT2FIX(mpz_probab_prime_p(self_val, reps_val));
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="remove-instance_method">
  
    - (<tt>Object</tt>) <strong>remove</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
call-seq:
</p>
<pre class="code">
  <span class='integer identifier id'>integer</span><span class='dot token'>.</span><span class='remove identifier id'>remove</span><span class='lparen token'>(</span><span class='factor identifier id'>factor</span><span class='rparen token'>)</span>
</pre>
<p>
From the GMP Manual:
</p>
<p>
Remove all occurrences of the factor <tt>factor</tt> from <tt>integer</tt>.
The return value is how many such occurrences were removed.
</p>


  </div>
</div>
<div class="tags">
  
</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/gmpz.c'</span>

/*
 * Document-method: remove
 *
 * call-seq:
 *   integer.remove(factor)
 *
 * From the GMP Manual:
 * 
 * Remove all occurrences of the factor +factor+ from +integer+. The return
 * value is how many such occurrences were removed.
 */
VALUE r_gmpz_remove(VALUE self, VALUE arg)
{
  MP_INT *self_val, *arg_val, *res_val;
  VALUE res;
  int   removed_val;
  int free_arg_val = 0;

  mpz_get_struct(self, self_val);

  if (GMPZ_P(arg)) {
    mpz_get_struct(arg,arg_val);
    if (mpz_sgn(arg_val) != 1)
      rb_raise(rb_eRangeError, &quot;argument must be positive&quot;);
  } else if (FIXNUM_P(arg)) {
    if (FIX2INT(arg) &lt;= 0)
      rb_raise(rb_eRangeError, &quot;argument must be positive&quot;);
    mpz_temp_alloc(arg_val);
    mpz_init_set_ui(arg_val, FIX2INT(arg));
  } else if (BIGNUM_P(arg)) {
    mpz_temp_from_bignum(arg_val, arg);
    if (mpz_sgn(arg_val) != 1) {
      mpz_temp_free(arg_val);
      rb_raise(rb_eRangeError, &quot;argument must be positive&quot;);
    }
  } else {
    typeerror(ZXB);
  }

  mpz_make_struct_init(res, res_val);
  removed_val = mpz_remove(res_val, self_val, arg_val);

  if (free_arg_val)
    mpz_temp_free(arg_val);

  return rb_assoc_new(res, INT2FIX(removed_val));
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="root-instance_method">
  
    - (<tt>Object</tt>) <strong>root</strong> 
  

  
</p>
</div>
    
      <div class="method_details ">
  <p class="signature " id="scan0-instance_method">
  
    - (<tt>Object</tt>) <strong>scan0</strong>(starting_bit) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
From the GMP Manual:
</p>
<p>
Scan integer, starting from bit starting_bit, towards more significant
bits, until the first 0 bit is found. Return the index of the found bit.
</p>
<p>
If the bit at starting_bit is already what&#8217;s sought, then
starting_bit is returned.
</p>
<p>
If there&#8217;s no bit found, then INT2FIX(ULONG_MAX) is returned. This
will happen in scan0 past the end of a negative number.
</p>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/gmpz.c'</span>

/*
 * call-seq:
 *   integer.scan0(starting_bit)
 *
 * From the GMP Manual:
 * 
 * Scan integer, starting from bit starting_bit, towards more significant bits,
 * until the first 0 bit is found. Return the index of the found bit.
 *
 * If the bit at starting_bit is already what's sought, then starting_bit is
 * returned.
 * 
 * If there's no bit found, then INT2FIX(ULONG_MAX) is returned. This will
 * happen in scan0 past the end of a negative number.
 */
VALUE r_gmpz_scan0(VALUE self, VALUE bitnr)
{
  MP_INT *self_val;
  int bitnr_val;
  mpz_get_struct(self, self_val);
  if (FIXNUM_P(bitnr)) {
    bitnr_val = FIX2INT (bitnr);
  } else {
    typeerror_as(X, &quot;index&quot;);
  }
  return INT2FIX(mpz_scan0(self_val, bitnr_val));
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="scan1-instance_method">
  
    - (<tt>Object</tt>) <strong>scan1</strong>(starting_bit) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
From the GMP Manual:
</p>
<p>
Scan integer, starting from bit starting_bit, towards more significant
bits, until the first 1 bit is found. Return the index of the found bit.
</p>
<p>
If the bit at starting_bit is already what&#8217;s sought, then
starting_bit is returned.
</p>
<p>
If there&#8217;s no bit found, then INT2FIX(ULONG_MAX) is returned. This
will happen in mpz_scan1 past the end of a nonnegative number.
</p>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/gmpz.c'</span>

/*
 * call-seq:
 *   integer.scan1(starting_bit)
 *
 * From the GMP Manual:
 * 
 * Scan integer, starting from bit starting_bit, towards more significant bits,
 * until the first 1 bit is found. Return the index of the found bit.
 *
 * If the bit at starting_bit is already what's sought, then starting_bit is
 * returned.
 *
 * If there's no bit found, then INT2FIX(ULONG_MAX) is returned. This will
 * happen in mpz_scan1 past the end of a nonnegative number.
 */
VALUE r_gmpz_scan1(VALUE self, VALUE bitnr)
{
  MP_INT *self_val;
  int bitnr_val;

  mpz_get_struct(self, self_val);

  if (FIXNUM_P(bitnr)) {
    bitnr_val = FIX2INT (bitnr);
  } else {
    typeerror_as(X, &quot;index&quot;);
  }

  return INT2FIX(mpz_scan1(self_val, bitnr_val));
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="sgn-instance_method">
  
    - (<tt>Object</tt>) <strong>sgn</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
From the GMP Manual:
</p>
<p>
Returns <tt>1 if </tt>integer+ &gt; 0, 0 if <tt>integer</tt> == 0, and -1
if <tt>integer</tt> &lt; 0.
</p>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/gmpz.c'</span>

/*
 * call-seq:
 *   integer.sgn
 *
 * From the GMP Manual:
 * 
 * Returns +1 if +integer+ &gt; 0, 0 if +integer+ == 0, and -1 if +integer+ &lt; 0.
 */
VALUE r_gmpz_sgn(VALUE self)
{
  MP_INT *self_val;
  mpz_get_struct(self, self_val);
  return INT2FIX(mpz_sgn(self_val));
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="sqrt-instance_method">
  
    - (<tt>Object</tt>) <strong>sqrt</strong> 
  

  
</p>
</div>
    
      <div class="method_details ">
  <p class="signature " id="sqrt!-instance_method">
  
    - (<tt>Object</tt>) <strong>sqrt!</strong> 
  

  
</p>
</div>
    
      <div class="method_details ">
  <p class="signature " id="sqrtrem-instance_method">
  
    - (<tt>Object</tt>) <strong>sqrtrem</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
call-seq:
</p>
<pre class="code">
  <span class='integer identifier id'>integer</span><span class='dot token'>.</span><span class='sqrtrem identifier id'>sqrtrem</span> <span class='comment val'>#=&gt; sqrt, rem</span>
</pre>
<p>
From the GMP Manual:
</p>
<p>
Returns the truncated integer part of the square root of <tt>integer</tt>
as <tt>sqrt</tt> and the remainder <tt>integer - sqrt * sqrt</tt> as
<tt>rem</tt>, which will be zero if <tt>integer</tt> is a perfect square.
</p>


  </div>
</div>
<div class="tags">
  
</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/gmpz.c'</span>

/*
 * Document-method: sqrtrem
 *
 * call-seq:
 *   integer.sqrtrem #=&gt; sqrt, rem
 *
 * From the GMP Manual:
 * 
 * Returns the truncated integer part of the square root of +integer+ as
 * +sqrt+ and the remainder &lt;tt&gt;integer - sqrt * sqrt&lt;/tt&gt; as +rem+, which will
 * be zero if +integer+ is a perfect square.
 */
static VALUE r_gmpz_sqrtrem(VALUE self)
{
  MP_INT *self_val, *sqrt_val, *rem_val;
  VALUE sqrt, rem;

  mpz_get_struct(self, self_val);
  mpz_make_struct_init(sqrt, sqrt_val);
  mpz_make_struct_init(rem, rem_val);
  mpz_sqrtrem(sqrt_val, rem_val, self_val);
  return rb_assoc_new(sqrt, rem);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="square?-instance_method">
  
    - (<tt>Boolean</tt>) <strong>square?</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
</div>
    
      <div class="method_details ">
  <p class="signature " id="sub!-instance_method">
  
    - (<tt>Object</tt>) <strong>sub!</strong>(other) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Subtracts other from this GMP::Z, and sets this GMP::Z&#8217;s value to the
result. Other can be
</p>
<ul>
<li>GMP::Z

</li>
<li>Fixnum

</li>
<li>GMP::Q

</li>
<li>GMP::F

</li>
<li>Bignum

</li>
</ul>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/gmpz.c'</span>

/*
 * call-seq:
 *   sub!(other)
 *
 * Subtracts other from this GMP::Z, and sets this GMP::Z's value to the
 * result. Other can be
 * * GMP::Z
 * * Fixnum
 * * GMP::Q
 * * GMP::F
 * * Bignum
 */
VALUE r_gmpz_sub_self(VALUE self, VALUE arg)
{
  MP_INT *self_val, *arg_val;

  mpz_get_struct(self,self_val);

  if (GMPZ_P(arg)) {
    mpz_get_struct(arg, arg_val);
    mpz_sub (self_val, self_val, arg_val);
  } else if (FIXNUM_P(arg)) {
    if (FIX2INT(arg) &gt; 0)
      mpz_sub_ui (self_val, self_val, FIX2INT(arg));
    else
      mpz_add_ui (self_val, self_val, -FIX2INT(arg));
  } else if (BIGNUM_P(arg)) {
    mpz_temp_from_bignum(arg_val, arg);
    mpz_sub (self_val, self_val, arg_val);
    mpz_temp_free (arg_val);
  } else {
    typeerror (ZXB);
  }
  return Qnil;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="swap-instance_method">
  
    - (<tt>Object</tt>) <strong>int2</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Efficiently swaps the contents of <tt>int1</tt> with <tt>int2</tt>.
</p>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/gmpz.c'</span>

/*
 * call-seq:
 *   int1.swap int2
 *
 * Efficiently swaps the contents of +int1+ with +int2+.
 */
VALUE r_gmpz_swap(VALUE self, VALUE arg)
{
  MP_INT *self_val, *arg_val;
  if (!GMPZ_P(arg)) {
    rb_raise(rb_eTypeError, &quot;Can't swap GMP::Z with object of other class&quot;);
  }
  mpz_get_struct(self, self_val);
  mpz_get_struct(arg, arg_val);
  mpz_swap(self_val,arg_val);
  return Qnil;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="tdiv-instance_method">
  
    - (<tt>Object</tt>) <strong>tdiv</strong> 
  

  
</p>
</div>
    
      <div class="method_details ">
  <p class="signature " id="tmod-instance_method">
  
    - (<tt>Object</tt>) <strong>tmod</strong> 
  

  
</p>
</div>
    
      <div class="method_details ">
  <p class="signature " id="to_d-instance_method">
  
    - (<tt>Object</tt>) <strong>to_d</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns <tt>integer</tt> as an Float if <tt>integer</tt> fits in a Float.
</p>
<p>
Otherwise returns the least significant part of <tt>integer</tt>, with the
same sign as <tt>integer</tt>.
</p>
<p>
If <tt>integer</tt> is too big to fit in a Float, the returned result is
probably not very useful. To find out if the value will fit, use the
function mpz_fits_slong_p (<b>Unimplemented</b>).
</p>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/gmpz.c'</span>

/*
 * call-seq:
 *   integer.to_d
 *
 * Returns +integer+ as an Float if +integer+ fits in a Float.
 *
 * Otherwise returns the least significant part of +integer+, with the same
 * sign as +integer+.
 *
 * If +integer+ is too big to fit in a Float, the returned result is probably
 * not very useful. To find out if the value will fit, use the function
 * mpz_fits_slong_p (&lt;b&gt;Unimplemented&lt;/b&gt;).
 */
VALUE r_gmpz_to_d(VALUE self)
{
  MP_INT *self_val;
  mpz_get_struct(self, self_val);

  return rb_float_new(mpz_get_d(self_val));
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="to_i-instance_method">
  
    - (<tt>Object</tt>) <strong>to_i</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns <tt>integer</tt> as an Fixnum if <tt>integer</tt> fits in a Fixnum.
</p>
<p>
Otherwise returns the least significant part of <tt>integer</tt>, with the
same sign as <tt>integer</tt>.
</p>
<p>
If <tt>integer</tt> is too big to fit in a Fixnum, the returned result is
probably not very useful. To find out if the value will fit, use the
function mpz_fits_slong_p (<b>Unimplemented</b>).
</p>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/gmpz.c'</span>

/*
 * call-seq:
 *   integer.to_i
 *
 * Returns +integer+ as an Fixnum if +integer+ fits in a Fixnum.
 *
 * Otherwise returns the least significant part of +integer+, with the same
 * sign as +integer+.
 *
 * If +integer+ is too big to fit in a Fixnum, the returned result is probably
 * not very useful. To find out if the value will fit, use the function
 * mpz_fits_slong_p (&lt;b&gt;Unimplemented&lt;/b&gt;).
 */
VALUE r_gmpz_to_i(VALUE self)
{
  MP_INT *self_val;
  char *str;
  VALUE res;

  mpz_get_struct(self, self_val);
  if (mpz_fits_slong_p(self_val))
    return rb_int2inum(mpz_get_si(self_val));
  str = mpz_get_str(NULL, 0, self_val);
  res = rb_cstr2inum(str, 10);
  free(str);
  return res;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="to_s-instance_method">
  
    - (<tt>Object</tt>) <strong>to_s</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
call-seq:
</p>
<pre class="code">
  <span class='integer identifier id'>integer</span><span class='dot token'>.</span><span class='to_s identifier id'>to_s</span><span class='lparen token'>(</span><span class='base identifier id'>base</span> <span class='assign token'>=</span> <span class='integer val'>10</span><span class='rparen token'>)</span>
</pre>
<p>
Returns <tt>integer</tt>, as a Ruby string. If <tt>base</tt> is not
provided, then the string will be the decimal representation.
</p>
<p>
From the GMP Manual:
</p>
<p>
Convert <tt>integer</tt> to a string of digits in base <tt>base</tt>. The
<tt>base</tt> argument may vary from 2 to 62 or from -2 to -36.
</p>
<p>
For <tt>base</tt> in the range 2..36, digits and lower-case letters are
used; for -2..-36, digits and upper-case letters are used; for 37..62,
digits, upper-case letters, and lower-case letters (in that significance
order) are used.
</p>


  </div>
</div>
<div class="tags">
  
</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/gmpz.c'</span>

/*
 * Document-method: to_s
 *
 * call-seq:
 *   integer.to_s(base = 10)
 *
 * Returns +integer+, as a Ruby string. If +base+ is not provided, then
 * the string will be the decimal representation.
 *
 * From the GMP Manual:
 *
 * Convert +integer+ to a string of digits in base +base+. The +base+ argument
 * may vary from 2 to 62 or from -2 to -36.
 *
 * For +base+ in the range 2..36, digits and lower-case letters are used; for
 * -2..-36, digits and upper-case letters are used; for 37..62, digits,
 * upper-case letters, and lower-case letters (in that significance order) are
 * used.
 */
VALUE r_gmpz_to_s(int argc, VALUE *argv, VALUE self)
{
  MP_INT *self_val;
  char *str;
  VALUE res;
  VALUE base;
  int base_val = 10;
  ID base_id;
  const char * bin_base = &quot;bin&quot;;                            /* binary */
  const char * oct_base = &quot;oct&quot;;                             /* octal */
  const char * dec_base = &quot;dec&quot;;                           /* decimal */
  const char * hex_base = &quot;hex&quot;;                       /* hexadecimal */
  ID bin_base_id = rb_intern(bin_base);
  ID oct_base_id = rb_intern(oct_base);
  ID dec_base_id = rb_intern(dec_base);
  ID hex_base_id = rb_intern(hex_base);  
  
  rb_scan_args(argc, argv, &quot;01&quot;, &amp;base);
  if (NIL_P(base)) { base = INT2FIX(10); }           /* default value */
  if (FIXNUM_P(base)) {
    base_val = FIX2INT(base);
    if ((base_val &gt;=   2 &amp;&amp; base_val &lt;= 62) ||
        (base_val &gt;= -36 &amp;&amp; base_val &lt;= -2)) {
      /* good base */
    } else {
      base_val = 10;
      rb_raise(rb_eRangeError, &quot;base must be within [2, 62] or [-36, -2].&quot;);
    }
  } else if (SYMBOL_P(base)) {
    base_id = rb_to_id(base);
    if (base_id == bin_base_id) {
      base_val =  2;
    } else if (base_id == oct_base_id) {
      base_val =  8;
    } else if (base_id == dec_base_id) {
      base_val = 10;
    } else if (base_id == hex_base_id) {
      base_val = 16;
    } else {
      base_val = 10;  /* should raise an exception here. */
    }
  }

  Data_Get_Struct(self, MP_INT, self_val);
  str = mpz_get_str(NULL, base_val, self_val);
  res = rb_str_new2(str);
  free (str);

  return res;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="tshr-instance_method">
  
    - (<tt>Object</tt>) <strong>tshr</strong> 
  

  
</p>
</div>
    
      <div class="method_details ">
  <p class="signature " id="|-instance_method">
  
    - (<tt>Object</tt>) <strong>|</strong> 
  

  
</p>
</div>
    
  </div>

</div>
    
    <div id="footer">
  Generated on 12/22/09 14:40:05 by 
  <a href="http://yardoc.org" title="Yay! A Ruby Documentation Tool">yard</a>
  0.5.2 (ruby-1.8.6).
</div>

  </body>
</html>