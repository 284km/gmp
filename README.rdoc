=gmp

gmp is library providing Ruby bindings to GMP library. Here is the introduction
paragraph at http://gmplib.org/#WHAT :

* "GMP is a free library for arbitrary precision arithmetic, operating on
  signed integers, rational numbers, and floating point numbers. There is no
  practical limit to the precision except the ones implied by the available
  memory in the machine GMP runs on. GMP has a rich set of functions, and the
  functions have a regular interface.

* The main target applications for GMP are cryptography applications and
  research, Internet security applications, algebra systems, computational
  algebra research, etc.

* GMP is carefully designed to be as fast as possible, both for small operands
  and for huge operands. The speed is achieved by using fullwords as the basic
  arithmetic type, by using fast algorithms, with highly optimised assembly
  code for the most common inner loops for a lot of CPUs, and by a general
  emphasis on speed.

* GMP is faster than any other bignum library. The advantage for GMP increases
  with the operand sizes for many operations, since GMP uses asymptotically
  faster algorithms.

* The first GMP release was made in 1991. It is continually developed and
  maintained, with a new release about once a year.

* GMP is distributed under the GNU LGPL. This license makes the library free to
  use, share, and improve, and allows you to pass on the result. The license
  gives freedoms, but also sets firm restrictions on the use with non-free
  programs.

* GMP is part of the GNU project. For more information about the GNU project,
  please see the official GNU web site.

* GMP's main target platforms are Unix-type systems, such as GNU/Linux,
  Solaris, HP-UX, Mac OS X/Darwin, BSD, AIX, etc. It also is known to work on
  Windoze in 32-bit mode.

* GMP is brought to you by a team listed in the manual.

* GMP is carefully developed and maintained, both technically and legally. We
  of course inspect and test contributed code carefully, but equally
  importantly we make sure we have the legal right to distribute the
  contributions, meaning users can safely use GMP. To achieve this, we will ask
  contributors to sign paperwork where they allow us to distribute their work."

Only GMP 4 or newer is supported. The following environments have been tested by me:
  gmp gem 0.1.4.2 on:
  +-------------------------------------+-------------------+-----------+
  |    Platform                         |       Ruby        |    GMP    |
  +-------------------------------------+-------------------+-----------+
  | Cygwin on x86                       | (MRI) Ruby 1.8.7  | GMP 4.3.1 |
  | Linux (LinuxMint 7) on x86 (32-bit) | (MRI) Ruby 1.8.7  | GMP 4.3.1 |
  | Mac OS X 10.5.7 on x86 (32-bit)     | (MRI) Ruby 1.8.6  | GMP 4.3.1 |
  | Mac OS X 10.5.7 on x86 (32-bit)     | (MRI) Ruby 1.9.1  | GMP 4.3.1 |
  +-------------------------------------+-------------------+-----------+

<b>Note:</b> To get this running on Mac OS X (32-bit), I compiled GMP 4.3.1 with:
  ./configure ABI=32 --disable-dependency-tracking

=Authors

* Tomasz Wegrzanowski
* srawlins

=Classes

It provides module GMP with following classes:
* GMP::Z - infinite precision integer numbers
* GMP::Q - infinite precision rational numbers
* GMP::F - arbitrary precision floating point numbers

Numbers are created by using new().
Constructors can take following arguments:

  GMP::Z.new()
  GMP::Z.new(GMP::Z)
  GMP::Z.new(FixNum)
  GMP::Z.new(BigNum)
  GMP::Z.new(String)
  GMP::Q.new()
  GMP::Q.new(GMP::Q)
  GMP::Q.new(String)
  GMP::Q.new(any GMP::Z initializer)
  GMP::Q.new(any GMP::Z initializer, any GMP::Z initializer)
  GMP::F.new()
  GMP::F.new(GMP::Z, precision=0)
  GMP::F.new(GMP::Q, precision=0)
  GMP::F.new(GMP::F)
  GMP::F.new(GMP::F, precision)
  GMP::F.new(String, precision=0)
  GMP::F.new(FixNum, precision=0)
  GMP::F.new(BigNum, precision=0)
  GMP::F.new(Float,  precision=0)

You can also call them as:
        GMP.Z(args)
        GMP.Q(args)
  todo  GMP.F(args)

=Methods

  GMP::Z, GMP::Q and GMP::F
    +                        addition
    -                        substraction
    *                        multiplication
    to_s                     convert to string. For GMP::Z, this method takes
                             one optional argument, a base. The base can be a
                             Fixnum in the ranges [2, 62] or [-36, -2] or a
                             Symbol: :bin, :oct, :dec, or :hex.
    -@                       negation
    neg!                     in-place negation
    abs                      absolute value
    asb!                     in-place absolute value
    coerce                   promotion of arguments
    ==                       equality test
    <=>,>=,>,<=,<            comparisions
  class methods of GMP::Z
    fac(n)                   factorial of n
    fib(n)                   nth fibonacci number
    pow(n,m)                 n to mth power
  GMP::Z and GMP::Q
    swap                     efficiently swap contents of two objects, there
                             is no GMP::F.swap because various GMP::F objects
                             may have different precisions, which would make
                             them unswapable
  GMP::Z
   .add!                     in-place addition
   .sub!                     in-place subtraction
    tdiv,fdiv,cdiv           truncate, floor and ceil division
    tmod,fmod,cmod           truncate, floor and ceil modulus
   .[],[]=                   testing and setting bits (as booleans)
    scan0,scan1              starting at bitnr (1st arg), scan for a 0 or 1
                             (respectively), then return the index of the
                             first instance.
    com                      2's complement
    com!                     in-place 2's complement
    &,|,^                    logical operations: and, or, xor
    **                       power
    powmod                   power modulo
    even?                    is even
    odd?                     is odd
    <<                       shift left
    >>                       shift right, floor
    tshr                     shift right, truncate
    lastbits_pos(n)          last n bits of object, modulo if negative
    lastbits_sgn(n)          last n bits of object, preserve sign
    power?                   is perfect power
    square?                  is perfect square
    sqrt                     square root
    sqrt!                    change the object into its square root
    root(n)                  nth root
    jacobi                   jacobi symbol
    legendre                 legendre symbol
    probab_prime?            0 if composite, 1 if probably prime, 2 if
                             certainly prime
    nextprime                next *probable* prime
    nextprime!               change the object into its next *probable* prime
    popcount                 the number of bits equal to 1
    to_i                     convert to FixNum or BigNum
    remove(n)                remove all occurences of factor n
  GMP::Q and GMP::F
    /                        division
  GMP::Q
    num                      numerator
    den                      denominator
    inv                      inversion
    inv!                     in-place inversion
    floor,ceil,trunc         nearest integer
  class methods of GMP::F
    default_prec             get default precision
    default_prec=            set default precision
  GMP::F
    prec                     get precision
    floor,ceil,trunc         nearest integer, GMP::F is returned, not GMP::Z
    floor!,ceil!,trunc!      in-place nearest integer
  GMP::F (only if MPFR is available)
    exp                      e^object
    expm1                    the same as (object.exp) - 1, with better precision
    log                      natural logarithm of object
    log2                     binary logarithm of object
    log10                    decimal logarithm of object
    log1p                    the same as (object + 1).log, with better precision
    sqrt                     square root of the object
    cos                      \
    sin                      |
    tan                      |
    acos                     |
    asin                     |
    atan                     | trigonometric functions
    cosh                     | of the object
    sinh                     |
    tanh                     |
    aconh                    |
    asinh                    |
    atanh                    /
    nan?                     \
    infinite?                | type of floating point number
    finite?                  |
    number?                  /
    **                       power

=Known Issues

* GMP::Z#pow does not appear to be working at all. Looking at the code, I don't
  think it ever did.

=Precision

Precision can be explicitely set as second argument for GMP::F.new().

If there is no explicit precision, highest precision of all GMP::F arguments is
used. That doesn't ensure that result will be exact. For details, consult any
paper about floating point arithmetics.

Default precision can be explicitely set by passing 0 to GMP::F.new(). In
particular, you can set precision of copy of GMP::F object by:
  new_obj = GMP::F.new(old_obj, 0)

Precision argument, and default_precision will be rounded up to whatever GMP
thinks is appropriate.

=Todo

These are inherited from Tomasz. I will go through these and see which are
still relevant.

* mpz_fits_* and 31 vs. 32 integer variables
* all appropriate module and class methods if there are any to add
* fix all sign issues (don't know what these are)
* floats with precision control
* random numbers
* to_s vs. inspect
* check if mpz_addmul_ui would optimize some statements
* some system that allows using denref and numref as normal ruby objects
* should we allocate global temporary variables like Perl GMP does?
* takeover code that replaces all Bignums with GMP::Z
* better bignum parser
* zero-copy method for strings generation
* put rb_raise into nice macros
* benchmarks against Python GMP and Perl GMP
* dup methods
* integrate F into system
* should Z.[] bits be 0/1 or true/false, 0 is true, what might badly surprise users
* seriously investigate Ruby Makefile-making system
* any2small_integer()
* check asm output, especially local memory efficiency
* it might be better to use `register' for some local variables
* powm with negative exponents
* check if different sorting of operatations gives better cache usage
* GMP::* op RubyFloat and RubyFloat op GMP::*
* sort checks
* check all new GMP4 operations
* GMP::Q.to_s(base), GMP::F.to_s(base)