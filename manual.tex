\documentclass[pdftex,10pt]{article}
\usepackage{amsmath,amsfonts,url}
\usepackage[pdftex]{graphicx}
\usepackage{booktabs}
\usepackage{url}
\setlength{\parindent}{0pt}
\def\cour{\fontfamily{pcr}\selectfont}
\usepackage[top=1in, bottom=0.8in, left=0.8in, right=0.8in]{geometry}
\setcounter{tocdepth}{3}
\newlength{\titrwidth}
\setlength{\titrwidth}{\textwidth}
\addtolength{\titrwidth}{-1.2in}
\newlength{\methwidth}
\setlength{\methwidth}{0.8in}
\newlength{\defnwidth}
\setlength{\defnwidth}{\textwidth}
\addtolength{\defnwidth}{-1.2in}
\addtolength{\heavyrulewidth}{\heavyrulewidth}
\def\qquad{\quad\quad}
\def\qqqquad{\quad\quad\quad\quad}
\begin{document}

\begin{tabular}{p{1.0in} p{\titrwidth}}
\huge{gmp} &\\
\midrule[3pt]
\multicolumn{2}{r}{\large{Ruby bindings to the GMP library}}\\
\multicolumn{2}{r}{\large{Edition 0.1.9}}\\
\multicolumn{2}{r}{\large{23 November 2009}}
\end{tabular}

\vfill
\large{written by Sam Rawlins}\\
\large{with extensive quoting from the GMP Manual}
\newpage

\vfill
This manual describes how to use the gmp Ruby gem, which provides bindings to
the GNU multiple precision arithmetic library, version 4.3.x.\\
\\
Copyright 2009 Sam Rawlins.\\
No license yet.
\newpage

\tableofcontents
\newpage

\section{Introduction to GNU MP}

This entire page is copied verbatim from the GMP Manual.\\\\

GNU MP is a portable library written in C for arbitrary precision arithmetic on
integers, rational numbers, and floating-point numbers. It aims to provide the
fastest possible arithmetic for all applications that need higher precision
than is directly supported by the basic C types.\\
\\
Many applications use just a few hundred bits of precision; but some
applications may need thousands or even millions of bits. GMP is designed to
give good performance for both, by choosing algorithms based on the sizes of
the operands, and by carefully keeping the overhead at a minimum.\\
\\
The speed of GMP is achieved by using fullwords as the basic arithmetic type,
by using sophisticated algorithms, by including carefully optimized assembly
code for the most common inner loops for many different CPUs, and by a general
emphasis on speed (as opposed to simplicity or elegance).\\
\\
There is assembly code for these CPUs: ARM, DEC Alpha 21064, 21164, and 21264,
AMD 29000, AMD K6, K6-2, Athlon, and Athlon64, Hitachi SuperH and SH-2, HPPA
1.0, 1.1, and 2.0, Intel Pentium, Pentium Pro/II/III, Pentium 4, generic x86,
Intel IA-64, i960, Motorola MC68000, MC68020, MC88100, and MC88110,
Motorola/IBM PowerPC 32 and 64, National NS32000, IBM POWER, MIPS R3000, R4000,
SPARCv7, SuperSPARC, generic SPARCv8, UltraSPARC, DEC VAX, and Zilog Z8000.
Some optimizations also for Cray vector systems, Clipper, IBM ROMP (RT), and
Pyramid AP/XP.\\
\\
For up-to-date information on GMP, please see the GMP web pages at\\
\setlength{\parindent}{0.25in}
\texttt{http://gmplib.org/}
\setlength{\parindent}{0in}
\\

The latest version of the library is available at\\
\setlength{\parindent}{0.25in}
\texttt{ftp://ftp.gnu.org/gnu/gmp/}\\
\setlength{\parindent}{0in}
\\

Many sites around the world mirror '\texttt{ftp.gnu.org}', please use a mirror
near you, see \texttt{http://www.gnu.org/order/ftp.html} for a full list.\\
\\
There are three public mailing lists of interest. One for release
announcements, one for general questions and discussions about usage of the GMP
library, and one for bug reports. For more information, see\\
\\
\texttt{http://gmplib.org/mailman/listinfo/}.\\
\\
The proper place for bug reports is gmp-bugs@gmplib.org. See Chapter 4
[Reporting Bugs], page 28 for information about reporting bugs.

\section{Introduction to the gmp gem}

The gmp Ruby gem is a Ruby library that provides bindings to GMP. The gem is
incomplete, and will likely only include a subset of the GMP functions. It is
built as a C extension for ruby, interacting with gmp.h. The gmp gem is not
endorsed or supported by GNU or the GMP team. The gmp gem also does not ship
with GMP, so GMP must be compiled separately.

\section{Installing the gmp gem}

\subsection{Prerequisites}
OK. First, we've got a few requirements. To install the gmp gem, you need one
of the following versions of Ruby:
\begin{itemize}
  \item (MRI) Ruby 1.8.6 - tested lightly.
  \item (MRI) Ruby 1.8.7 - tested seriously.
  \item (MRI) Ruby 1.9.1 - more of a "release candidate" state. Please report
    bugs.
\end{itemize}
As you can see only Matz's Ruby Interpreter (MRI) is supported. I haven't even
put a thought into trying other interpreters/VMs. I intend to look into FFI,
which supposedly will allow me to load this extension into JRuby and Rubinius,
not sure about others...\\

Next is the platform, the combination of the architecture (processor) and OS.
As far as I can tell, if you can compile GMP and Ruby on a given platform, you
can use the gmp gem there too. Please report problems with that hypothesis.\\

Lastly, GMP. GMP must be compiled and working. "and working" means you ran "make check" while installing GMP. The following versions of GMP have been tested:
\begin{itemize}
  \item GMP 4.3.1
\end{itemize}

That's all. I don't intend to test any older versions, maybe 4.3.0 for completeness.\\

Here is a table of the exact environments I have tested the gmp gem on:\\\\

\begin{tabular}{lrr} \hline
             Platform             &       Ruby       &    GMP    \\ \midrule[1pt]
  Cygwin on x86                   & (MRI) Ruby 1.8.7 & GMP 4.3.1 \\ \hline
  Linux (LinuxMint 7) on x86      & (MRI) Ruby 1.8.7 & GMP 4.3.1 \\ \hline
  Mac OS X 10.5.7 on x86 (32-bit) & (MRI) Ruby 1.8.6 & GMP 4.3.1 \\ \hline
  Mac OS X 10.5.7 on x86 (32-bit) & (MRI) Ruby 1.9.1 & GMP 4.3.1 \\ \hline
\end{tabular}

\subsection{Installing}
You may clone the gmp gem's git repository with:\\
\\
\texttt{git clone git://github.com/srawlins/gmp.git}\\

Or you may install the gem from github:\\
\\
\texttt{gem install srawlins-gmp}\\

At this time, the gem does not self-compile (how does that work?). To compile the C
extensions, do the following:\\
\\
\texttt{cd <srawlins-gmp gem directory>/ext}\\
\texttt{ruby extconf.rb}\\
\texttt{make}\\

There shouldn't be any errors, or warnings.

\section{GMP and gmp gem basics}

\subsection{Classes}
The gmp gem includes the namespace \texttt{GMP} and three classes within \texttt{GMP}:
\begin{itemize}
  \item \texttt{GMP::Z} - Methods for signed integer arithmetic. There are at least 35
    methods here (still accounting).
  \item \texttt{GMP::Q} - Methods for rational number arithmetic. There are at least 6
    methods here (still accounting).
  \item \texttt{GMP::F} - Methods for floating-point arithmetic. There are at least 0
    methods here (still accounting).
\end{itemize}

In addition to the above three classes, there is also one constant within \texttt{GMP}:
\begin{itemize}
  \item \texttt{GMP::GMP\_VERSION} - The version of GMP compiled into the gmp gem.
\end{itemize}

\newpage
\section{Integer Functions}

\subsection{Initializing, Assigning Integers}

\begin{tabular}{p{\methwidth} l r}
\toprule
\textbf{new} & & GMP::Z.new $\rightarrow$ \textit{integer} \\
& & GMP::Z.new(\textit{numeric = 0}) $\rightarrow$ \textit{integer} \\
& & GMP::Z.new(\textit{str}) $\rightarrow$ \textit{integer} \\
\cmidrule(r){2-3}
& \multicolumn{2}{p{\defnwidth}}{
  This method creates a new \textit{GMP::Z} integer. It takes one optional argument for
  the value of the integer. This argument can be one of several classes. Here are some
  examples:\newline
  
  \texttt{GMP::Z.new \qqqquad\qqqquad \#=> 0 (default) \newline
          GMP::Z.new(1) \qqqquad\qquad\  \#=> 1 (Ruby Fixnum) \newline
          GMP::Z.new("127") \qqqquad\  \#=> 127 (Ruby String)\newline
          GMP::Z.new(4294967296) \qquad \#=> 4294967296 (Ruby Bignum)\newline
          GMP::Z.new(GMP::Z.new(31))  \#=> 31 (GMP Integer)}
}
\end{tabular}
\newline\newline

There is also a convenience method available, \texttt{GMP::Z()}.\\

\subsection{Converting Integers}

\begin{tabular}{p{\methwidth} l r}
\toprule
\textbf{to\_d} & & \textit{integer}.to\_d $\rightarrow$ \textit{float} \\
\cmidrule(r){2-3}
& \multicolumn{2}{p{\defnwidth}}{
  Returns \textit{integer} as an Float if \textit{integer} fits in a Float.

  Otherwise returns the least significant part of \texttt{integer}, with the same sign as
  \textit{integer}.
  
  If \textit{integer} is too big to fit in a Float, the returned result is probably not
  very useful. To find out if the value will fit, use the function
  \textit{mpz\_fits\_slong\_p} (\textbf{Unimplemented}).
}
\end{tabular}
\newline\newline

\begin{tabular}{p{\methwidth} l r}
\toprule
\textbf{to\_i} & & \textit{integer}.to\_i $\rightarrow$ \textit{fixnum} \\
\cmidrule(r){2-3}
& \multicolumn{2}{p{\defnwidth}}{
  Returns \textit{integer} as a Fixnum if \textit{integer} fits in a Fixnum.
  \newline
  
  Otherwise returns the least significant part of \textit{integer}, with the same sign as
  \textit{integer}.
  \newline
  
  If \textit{integer} is too big to fit in a Fixnum, the returned result is probably not
  very useful. To find out if the value will fit, use the function
  \textit{mpz\_fits\_slong\_p} (\textbf{Unimplemented}).
}
\end{tabular}
\newline\newline

\begin{tabular}{p{\methwidth} l r}
\toprule
\textbf{to\_s} & & \textit{integer}.to\_s(\textit{base = 10}) $\rightarrow$ \textit{str} \\
\cmidrule(r){2-3}
& \multicolumn{2}{p{\defnwidth}}{
  Converts \textit{integer} to a string of digits in base \textit{base}. The
  \textit{base} argument may vary from 2 to 62 or from -2 to -36, or be a symbol, one of
  \textit{:bin}, \textit{:oct}, \textit{:dec}, or \textit{:hex}.
  \newline
  
  For \textit{base} in the range 2..36, digits and lower-case letters are used; for
  -2..-36 (and \textit{:bin}, \textit{:oct}, \textit{:dec}, and \textit{:hex}), digits
  and upper-case letters are used; for 37..62, digits, upper-case letters, and lower-case
  letters (in that significance order) are used. Here are some
  examples:\newline
  
  \texttt{GMP::Z(1).to\_s \qqqquad \#=> "1" \newline
          GMP::Z(32).to\_s(2) \qquad \#=> "100000" \newline
          GMP::Z(32).to\_s(4) \qquad \#=> "200" \newline
          GMP::Z(10).to\_s(16) \quad\  \#=> "a" \newline
          GMP::Z(10).to\_s(-16) \quad \#=> "A" \newline
          GMP::Z(255).to\_s(:bin) \#=> "11111111" \newline
          GMP::Z(255).to\_s(:oct) \#=> "377" \newline
          GMP::Z(255).to\_s(:dec) \#=> "255" \newline
          GMP::Z(255).to\_s(:hex) \#=> "ff"}
}
\end{tabular}

\subsection{Integer Arithmetic}

\begin{tabular}{p{\methwidth} l r}
\toprule
\textbf{+} & & \textit{integer} + \textit{numeric} $\rightarrow$ \textit{numeric} \\
\cmidrule(r){2-3}
& \multicolumn{2}{p{\defnwidth}}{
  Returns the sum of \textit{integer} and \textit{numeric}. \textit{numeric} can be a
  member of \textit{GMP::Z}, \textit{Fixnum}, \textit{GMP::Q}, \textit{GMP::F}, or
  \textit{Bignum}.
}
\end{tabular}
\newline\newline

\begin{tabular}{p{\methwidth} l r}
\toprule
\textbf{add} & & \textit{integer}.add(\textit{numeric}) $\rightarrow$ \textit{numeric} \\
\cmidrule(r){2-3}
& \multicolumn{2}{p{\defnwidth}}{
  Returns the sum of \textit{integer} and \textit{numeric}. \textit{numeric} can be a
  member of \textit{GMP::Z}, \textit{Fixnum}, \textit{GMP::Q}, \textit{GMP::F}, or
  \textit{Bignum}.
}
\end{tabular}
\newline\newline

\begin{tabular}{p{\methwidth} l r}
\toprule
\textbf{add!} & & \textit{integer}.add!(\textit{numeric}) $\rightarrow$
\textit{numeric} \\
\cmidrule(r){2-3}
& \multicolumn{2}{p{\defnwidth}}{
  Sums \textit{integer} and \textit{numeric}, in place. \textit{numeric} can be a
  member of \textit{GMP::Z}, \textit{Fixnum}, \textit{GMP::Q}, \textit{GMP::F}, or
  \textit{Bignum}.
}
\end{tabular}
\newline\newline

\begin{tabular}{p{\methwidth} l r}
\toprule
\textbf{-} & & \textit{integer} - \textit{numeric} $\rightarrow$ \textit{numeric} \\
& & \textit{integer}.sub(\textit{numeric}) $\rightarrow$ \textit{numeric} \\
& & \textit{integer}.sub!(\textit{numeric}) $\rightarrow$ \textit{numeric} \\
\cmidrule(r){2-3}
& \multicolumn{2}{p{\defnwidth}}{
  Returns the difference of \textit{integer} and \textit{numeric}. The destructive method
  calculates the difference in place. \textit{numeric} can be a member of
  \textit{GMP::Z}, \textit{Fixnum}, \textit{GMP::Q}, \textit{GMP::F}, or \textit{Bignum}.
}
\end{tabular}
\newline\newline

\begin{tabular}{p{\methwidth} l r}
\toprule
\textbf{*} & & \textit{integer} * \textit{numeric} $\rightarrow$ \textit{numeric} \\
& & \textit{integer}.mul(\textit{numeric}) $\rightarrow$ \textit{numeric} \\
& & \textit{integer}.mul!(\textit{numeric}) $\rightarrow$ \textit{numeric} \\
\cmidrule(r){2-3}
& \multicolumn{2}{p{\defnwidth}}{
  Returns the product of \textit{integer} and \textit{numeric}. The destructive method
  calculates the product in place. \textit{numeric} can be a member of \textit{GMP::Z},
  \textit{Fixnum}, \textit{GMP::Q}, \textit{GMP::F}, or \textit{Bignum}.
}
\end{tabular}
\newline\newline

\begin{tabular}{p{\methwidth} l r}
\toprule
\textbf{-@} & & -\textit{integer}\\
& & \textit{integer}.neg\\
& & \textit{integer}.neg!\\
\cmidrule(r){2-3}
& \multicolumn{2}{p{\defnwidth}}{
  Returns the negation, the additive inverse, of \textit{integer}. The destructive method
  negates in place.
}
\end{tabular}
\newline\newline

\begin{tabular}{p{\methwidth} l r}
\toprule
\textbf{abs} & & \textit{integer}.abs\\
& & \textit{integer}.abs!\\
\cmidrule(r){2-3}
& \multicolumn{2}{p{\defnwidth}}{
  Returns the absolute value of \textit{integer}. The destructive method calculates the
  absolute value in place.
}
\end{tabular}

\subsection{Integer Division}

\begin{tabular}{p{\methwidth} l r}
\toprule
\textbf{tdiv} & & \textit{integer}.tdiv(\textit{numeric}) $\rightarrow$ \textit{integer}\\
\cmidrule(r){2-3}
& \multicolumn{2}{p{\defnwidth}}{
  Returns the division of \textit{integer} by \textit{numeric}, truncated.
  \textit{numeric} can be a member of \textit{GMP::Z}, \textit{Fixnum}, \textit{Bignum}.
  The return object's class is always \textit{GMP::Z}.
}
\end{tabular}
\newline\newline

\begin{tabular}{p{\methwidth} l r}
\toprule
\textbf{fdiv} & & \textit{integer}.fdiv(\textit{numeric}) $\rightarrow$ \textit{integer}\\
\cmidrule(r){2-3}
& \multicolumn{2}{p{\defnwidth}}{
  Returns the division of \textit{integer} by \textit{numeric}, floored.
  \textit{numeric} can be a member of \textit{GMP::Z}, \textit{Fixnum}, \textit{Bignum}.
  The return object's class is always \textit{GMP::Z}.
}
\end{tabular}
\newline\newline

\begin{tabular}{p{\methwidth} l r}
\toprule
\textbf{cdiv} & & \textit{integer}.cdiv(\textit{numeric}) $\rightarrow$ \textit{integer}\\
\cmidrule(r){2-3}
& \multicolumn{2}{p{\defnwidth}}{
  Returns the ceiling division of \textit{integer} by \textit{numeric}.
  \textit{numeric} can be a member of \textit{GMP::Z}, \textit{Fixnum}, \textit{Bignum}.
  The return object's class is always \textit{GMP::Z}.
}
\end{tabular}
\newline\newline

\begin{tabular}{p{\methwidth} l r}
\toprule
\textbf{tmod} & & \textit{integer}.tmod(\textit{numeric}) $\rightarrow$ \textit{integer}\\
\cmidrule(r){2-3}
& \multicolumn{2}{p{\defnwidth}}{
  Returns the remainder after truncated division of \textit{integer} by \textit{numeric}.
  \textit{numeric} can be a member of \textit{GMP::Z}, \textit{Fixnum}, \textit{Bignum}.
  The return object's class is always \textit{GMP::Z}.
}
\end{tabular}
\newline\newline

\begin{tabular}{p{\methwidth} l r}
\toprule
\textbf{fmod} & & \textit{integer}.fmod(\textit{numeric}) $\rightarrow$ \textit{integer}\\
\cmidrule(r){2-3}
& \multicolumn{2}{p{\defnwidth}}{
  Returns the remainder after floored division of \textit{integer} by \textit{numeric}.
  \textit{numeric} can be a member of \textit{GMP::Z}, \textit{Fixnum}, \textit{Bignum}.
  The return object's class is always \textit{GMP::Z}.
}
\end{tabular}
\newline\newline

\begin{tabular}{p{\methwidth} l r}
\toprule
\textbf{cmod} & & \textit{integer}.cmod(\textit{numeric}) $\rightarrow$ \textit{integer}\\
\cmidrule(r){2-3}
& \multicolumn{2}{p{\defnwidth}}{
  Returns the remainder after ceilinged division of \textit{integer} by \textit{numeric}.
  \textit{numeric} can be a member of \textit{GMP::Z}, \textit{Fixnum}, \textit{Bignum}.
  The return object's class is always \textit{GMP::Z}.
}
\end{tabular}

\subsection{Integer Exponentiation}

\subsection{Integer Roots}

\begin{tabular}{p{\methwidth} l r}
\toprule
\textbf{root} & & \textit{integer}.root(\textit{numeric}) $\rightarrow$ \textit{numeric} \\
\cmidrule(r){2-3}
& \multicolumn{2}{p{\defnwidth}}{
  Returns the integer part of the \textit{numeric}'th root of \textit{integer}.
}
\end{tabular}

\end{document}